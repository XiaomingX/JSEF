package com.freedom.securitysamples.newfea.notaboutsafty;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * 竞态条件（Race Condition）漏洞示例控制器
 * 说明：竞态条件是指多个线程同时访问和操作共享资源时，由于执行顺序的不确定性，
 *       导致最终结果与预期不符的并发安全问题。这是多线程编程中常见的安全隐患。
 * 常见风险：
 * 1. 数据不一致（如计数器结果错误、金额计算错误）
 * 2. 资源状态异常（如订单重复创建、库存超卖）
 * 3. 程序逻辑混乱（依赖时序的操作执行顺序颠倒）
 * 修复原则：
 * 1. 对共享资源的操作进行同步控制（如使用synchronized关键字）
 * 2. 使用线程安全的数据结构（如AtomicInteger、ConcurrentHashMap）
 * 3. 采用乐观锁或悲观锁机制
 * 4. 最小化共享资源的作用域和暴露范围
 */
@RestController
@RequestMapping("/security-example/concurrency")
public class RaceConditionVulnerabilityController {

    // 共享计数器：多个线程会同时访问和修改此变量，存在竞态条件风险
    private int sharedCounter = 0;

    /**
     * 不安全示例：演示竞态条件问题
     * 漏洞点：
     * 1. 多个线程同时操作共享变量sharedCounter
     * 2. incrementCounter()方法未做任何同步处理
     * 3. count++操作在底层是"读取-修改-写入"三步操作，非原子操作
     * 预期结果：2000（两个线程各累加1000次）
     * 实际结果：通常小于2000，且每次运行结果可能不同
     */
    @GetMapping("/unsafe/race-condition-demo")
    public String demonstrateRaceCondition() {
        // 重置计数器
        sharedCounter = 0;

        // 创建两个线程模拟并发访问
        Thread thread1 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                incrementCounter(); // 调用非线程安全的递增方法
            }
        }, "Counter-Thread-1");

        Thread thread2 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                incrementCounter(); // 调用非线程安全的递增方法
            }
        }, "Counter-Thread-2");

        // 启动线程
        thread1.start();
        thread2.start();

        // 等待两个线程执行完毕
        try {
            thread1.join();  // 等待线程1完成
            thread2.join();  // 等待线程2完成
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt(); // 恢复中断状态
            return "演示被中断：" + e.getMessage();
        }

        // 返回最终计数结果（通常不等于2000，体现竞态条件问题）
        return String.format("竞态条件演示结果（预期2000）：%d", sharedCounter);
    }

    /**
     * 非线程安全的计数器递增方法
     * 问题解析：
     * count++操作实际包含三个步骤：
     * 1. 读取当前count值到寄存器
     * 2. 寄存器中的值加1
     * 3. 将新值写回count变量
     * 多线程环境下，这三步操作可能被其他线程打断，导致数据覆盖
     */
    private void incrementCounter() {
        sharedCounter++; // 非原子操作，存在竞态条件风险
    }

    /**
     * 安全示例：使用synchronized关键字修复竞态条件
     * 修复原理：
     * 通过synchronized关键字保证同一时间只有一个线程能执行临界区代码，
     * 确保"读取-修改-写入"操作的原子性
     */
    @GetMapping("/safe/synchronized-demo")
    public String demonstrateSynchronizedFix() {
        sharedCounter = 0;

        Thread thread1 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                safeIncrementWithSynchronized();
            }
        });

        Thread thread2 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                safeIncrementWithSynchronized();
            }
        });

        thread1.start();
        thread2.start();

        try {
            thread1.join();
            thread2.join();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            return "演示被中断：" + e.getMessage();
        }

        return String.format("同步方法修复结果（预期2000）：%d", sharedCounter);
    }

    /**
     * 线程安全的递增方法：使用synchronized关键字
     * synchronized保证了方法的原子性，同一时间只有一个线程可以执行
     */
    private synchronized void safeIncrementWithSynchronized() {
        sharedCounter++;
    }
}