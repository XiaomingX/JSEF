package com.freedom.securitysamples.newfea.notaboutsafty;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * 哈希碰撞攻击漏洞示例控制器
 * 说明：哈希碰撞攻击是指攻击者构造大量具有相同哈希值的输入数据，
 *       利用哈希表（如HashMap）在处理哈希冲突时的性能缺陷，导致系统处理时间剧增，
 *       最终造成拒绝服务（DoS）攻击。
 * 常见风险：
 * 1. 服务器CPU资源耗尽，响应时间大幅延长
 * 2. 服务不可用，无法处理正常请求
 * 3. 可能引发连锁反应，影响整个系统稳定性
 * 修复原则：
 * 1. 限制输入数据的大小和数量
 * 2. 使用对哈希碰撞攻击有防护机制的数据结构（如Java 8+的ConcurrentHashMap）
 * 3. 对用户输入进行哈希处理后再作为键值，避免直接使用原始输入
 * 4. 实施请求频率限制，防止大量恶意请求
 */
@RestController
@RequestMapping("/security-example/hash-collision")
public class HashCollisionVulnerabilityController {

    /**
     * 不安全示例：直接使用用户输入作为HashMap的键
     * 漏洞点：
     * 1. 用户输入未做任何处理直接作为HashMap的key
     * 2. HashMap在处理大量哈希碰撞时，查询/插入操作时间复杂度从O(1)退化为O(n)
     * 攻击原理：
     * 攻击者可构造大量具有相同哈希值的字符串（如特定前缀的字符串），
     * 当这些字符串被作为key存入HashMap时，会形成长长的链表，
     * 导致系统处理这些操作时消耗大量CPU资源，无法响应正常请求。
     * 示例攻击：提交大量精心构造的、哈希值相同的input参数
     */
    @GetMapping("/unsafe/add-to-hashmap")
    public String unsafeAddToHashMap(@RequestParam(name = "input") String input) {
        // 危险实践：直接使用用户可控输入作为HashMap的key
        Map<String, String> hashMap = new HashMap<>();
        hashMap.put(input, "value"); // 这里存在哈希碰撞攻击风险
        
        return "用户输入已作为键添加到HashMap（不安全实现）";
    }

    /**
     * 安全示例：使用安全机制防护哈希碰撞攻击
     * 修复措施：
     * 1. 使用ConcurrentHashMap（Java 8+中对哈希碰撞有优化，采用红黑树替代长链表）
     * 2. 对用户输入进行哈希处理后再作为键，减少原始输入直接碰撞的可能
     * 3. 限制输入长度，降低大规模碰撞的影响范围
     */
    @GetMapping("/safe/add-to-hashmap")
    public String safeAddToHashMap(@RequestParam(name = "input") String input) {
        // 安全措施1：限制输入长度，防止超大输入
        if (input.length() > 100) {
            return "输入长度超过限制（最大100字符）";
        }
        
        try {
            // 安全措施2：对用户输入进行哈希处理，使用固定长度的哈希值作为key
            MessageDigest digest = MessageDigest.getInstance("SHA-256");
            byte[] hashBytes = digest.digest(input.getBytes(StandardCharsets.UTF_8));
            String safeKey = bytesToHex(hashBytes); // 转换为十六进制字符串
            
            // 安全措施3：使用ConcurrentHashMap，对哈希碰撞有更好的处理机制
            Map<String, String> safeMap = new ConcurrentHashMap<>();
            safeMap.put(safeKey, "value");
            
            return "用户输入经安全处理后已添加到HashMap（安全实现）";
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException("哈希算法初始化失败", e);
        }
    }
    
    // 辅助方法：将字节数组转换为十六进制字符串
    private String bytesToHex(byte[] bytes) {
        StringBuilder hexString = new StringBuilder();
        for (byte b : bytes) {
            String hex = Integer.toHexString(0xff & b);
            if (hex.length() == 1) {
                hexString.append('0');
            }
            hexString.append(hex);
        }
        return hexString.toString();
    }
}