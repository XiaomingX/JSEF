package com.freedom.securitysamples.api.commandInjection;

import org.springframework.web.bind.annotation.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;

/**
 * 命令注入漏洞示例控制器
 * 说明：命令注入是指攻击者通过构造恶意输入，使应用程序执行非预期的系统命令
 * 这种漏洞通常发生在应用程序直接使用用户输入拼接或执行系统命令时
 * 
 * 常见风险：
 * 1. 服务器被完全控制（执行任意命令、创建管理员账号等）
 * 2. 敏感数据泄露（读取/etc/passwd、数据库配置文件等）
 * 3. 数据被篡改或删除（rm -rf /等破坏性命令）
 * 4. 作为跳板攻击内网其他系统
 * 
 * 修复原则：
 * 1. 禁止直接使用用户输入执行系统命令
 * 2. 若必须执行命令，使用白名单限制允许的命令和参数
 * 3. 使用参数化方式传递参数，避免字符串拼接
 * 4. 最小权限原则：运行应用的系统用户应仅拥有必要权限
 * 5. 采用安全的API，避免使用Runtime.exec()等直接执行命令的方法
 */
@RestController
@RequestMapping("/security-example/command-injection")
public class CommandInjectionVulnerabilityController {

    /**
     * 不安全示例1：直接执行用户输入的完整命令
     * 漏洞点：将用户输入作为完整命令直接执行，未做任何过滤
     * 风险：攻击者可输入任意系统命令，完全控制服务器
     * 示例攻击输入：ls; cat /etc/passwd （执行ls后再读取系统用户文件）
     * 示例攻击输入：rm -rf /tmp/* （删除/tmp目录下所有文件）
     */
    @GetMapping("/unsafe/raw-command")
    public String unsafeExecuteRawCommand(@RequestParam String command) {
        StringBuilder output = new StringBuilder();

        try {
            // 危险实践：直接将用户输入作为命令执行
            Process process = Runtime.getRuntime().exec(command);

            BufferedReader reader = new BufferedReader(
                    new InputStreamReader(process.getInputStream())
            );

            String line;
            while ((line = reader.readLine()) != null) {
                output.append(line).append("\n");
            }

            process.waitFor();
            reader.close();

            return "命令输出:\n" + output.toString();

        } catch (Exception e) {
            return "命令执行错误: " + e.getMessage();
        }
    }

    /**
     * 不安全示例2：通过字符串拼接构建命令
     * 漏洞点：将用户输入直接拼接到命令字符串中
     * 风险：攻击者可注入命令分隔符（;、&&、|等）执行额外命令
     * 示例攻击输入：/etc/passwd; ls （读取密码文件后执行ls）
     * 示例攻击输入：dummy.txt && rm -rf /var/log/* （删除日志文件）
     */
    @GetMapping("/unsafe/concatenated-command")
    public String unsafeExecuteConcatenatedCommand(@RequestParam String fileName) {
        StringBuilder output = new StringBuilder();
        try {
            // 危险实践：直接拼接用户输入到命令中，形成注入风险
            String command = "cat " + fileName; // 假设意图是查看指定文件内容
            Process process = Runtime.getRuntime().exec(command);

            BufferedReader reader = new BufferedReader(
                    new InputStreamReader(process.getInputStream())
            );

            String line;
            while ((line = reader.readLine()) != null) {
                output.append(line).append("\n");
            }

            return "文件内容:\n" + output.toString();
        } catch (Exception e) {
            return "命令执行错误: " + e.getMessage();
        }
    }

    /**
     * 不安全示例3：使用命令数组但未验证命令本身
     * 漏洞点：允许用户指定要执行的命令，仅参数验证不足
     * 风险：攻击者可指定任意危险命令（如rm、cp等）进行破坏
     * 示例攻击输入：command=rm&arg=-rf%20/tmp/test （执行删除操作）
     * 示例攻击输入：command=cp&arg=/etc/passwd%20/public/ （泄露敏感文件）
     */
    @GetMapping("/unsafe/unvalidated-array")
    public String unsafeExecuteCommandArray(
            @RequestParam String command, 
            @RequestParam String arg) {
        StringBuilder output = new StringBuilder();
        try {
            // 危险实践：允许用户指定命令本身，即使使用数组也不安全
            String[] cmdArray = {command, arg};
            Process process = Runtime.getRuntime().exec(cmdArray);

            BufferedReader reader = new BufferedReader(
                    new InputStreamReader(process.getInputStream())
            );

            String line;
            while ((line = reader.readLine()) != null) {
                output.append(line).append("\n");
            }

            return "命令输出:\n" + output.toString();
        } catch (Exception e) {
            return "命令执行错误: " + e.getMessage();
        }
    }

    /**
     * 不安全示例4：使用ProcessBuilder但拆分方式不安全
     * 漏洞点：通过字符串拆分构建命令数组，仍可能被注入特殊字符
     * 风险：攻击者可通过空格、引号等绕过简单拆分，注入恶意命令
     * 示例攻击输入：ls; cat /etc/passwd （拆分后仍会执行多个命令）
     * 示例攻击输入："ls; rm -rf /tmp/logs" （带引号的恶意命令）
     */
    @GetMapping("/unsafe/process-builder")
    public String unsafeExecuteWithProcessBuilder(@RequestParam String command) {
        StringBuilder output = new StringBuilder();
        try {
            // 危险实践：使用split(" ")拆分命令，无法正确处理特殊字符和空格
            ProcessBuilder processBuilder = new ProcessBuilder(command.split(" "));
            processBuilder.redirectErrorStream(true); // 合并错误输出
            Process process = processBuilder.start();

            BufferedReader reader = new BufferedReader(
                    new InputStreamReader(process.getInputStream())
            );

            String line;
            while ((line = reader.readLine()) != null) {
                output.append(line).append("\n");
            }

            return "命令输出:\n" + output.toString();
        } catch (Exception e) {
            return "命令执行错误: " + e.getMessage();
        }
    }

    /**
     * 安全示例1：使用白名单限制允许的命令和参数
     * 修复点：
     * 1. 命令固定，不允许用户指定
     * 2. 参数通过白名单验证（仅允许特定格式的文件名）
     * 3. 使用命令数组传递参数，避免字符串拼接
     */
    @GetMapping("/safe/whitelisted-command")
    public String safeExecuteWithWhitelist(@RequestParam String fileName) {
        StringBuilder output = new StringBuilder();
        try {
            // 安全实践1：验证参数格式（仅允许字母、数字、下划线和扩展名）
            if (!fileName.matches("^[a-zA-Z0-9_]+\\.txt$")) {
                return "错误：文件名格式不合法，仅允许字母、数字、下划线和.txt扩展名";
            }

            // 安全实践2：命令固定，不允许用户修改
            // 安全实践3：使用数组形式传递参数，避免解析问题
            String[] cmdArray = {"cat", "/var/safe-docs/" + fileName}; // 限制文件路径
            Process process = Runtime.getRuntime().exec(cmdArray);

            BufferedReader reader = new BufferedReader(
                    new InputStreamReader(process.getInputStream())
            );

            String line;
            while ((line = reader.readLine()) != null) {
                output.append(line).append("\n");
            }

            return "安全文件内容:\n" + output.toString();
        } catch (Exception e) {
            return "命令执行错误: " + e.getMessage();
        }
    }
}
