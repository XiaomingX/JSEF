package com.freedom.securitysamples.api.weakPassword;

import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

/**
 * 弱密码漏洞示例控制器
 * 说明：弱密码是指容易被猜测或暴力破解的密码，是应用系统最常见的安全隐患之一
 * 常见风险：
 * 1. 账号被未授权访问（暴力破解、字典攻击）
 * 2. 敏感信息泄露
 * 3. 身份盗用与欺诈
 * 4. 系统被恶意控制
 * 修复原则：
 * 1. 实施密码强度策略（长度≥8位，包含大小写字母、数字和特殊字符）
 * 2. 禁止使用常见弱密码（如123456、admin等）
 * 3. 使用加密哈希存储密码（如BCrypt、Argon2），禁止明文存储
 * 4. 限制登录尝试次数，防止暴力破解
 * 5. 支持双因素认证增强安全性
 */
@RestController
@RequestMapping("/security-example/weak-password")
public class WeakPasswordVulnerabilityController {

    /**
     * 不安全示例：允许使用常见弱密码并明文处理密码
     * 漏洞点：
     * 1. 接受极易被猜测的弱密码（123456、admin等）
     * 2. 密码以明文形式进行比较和传输
     * 3. 登录成功响应中泄露密码明文
     * 4. 未实施任何密码强度验证机制
     * 5. 没有防暴力破解措施
     */
    @PostMapping("/unsafe/login")
    public String unsafeLoginWithWeakPassword(
            @RequestParam String username,
            @RequestParam String password) {
        
        // 危险实践：直接使用明文比较密码
        // 常见弱密码列表 - 实际系统中这些密码都应被拒绝
        if ("123456".equals(password)) {
            // 严重漏洞：在响应中返回明文密码
            return "{\"msg\":\"登录成功（使用弱密码）\",\"username\":\"" + username + "\",\"password\":\"123456\"}";
        }
        if ("admin".equals(password)) {
            return "{\"msg\":\"登录成功（使用弱密码）\",\"username\":\"" + username + "\",\"password\":\"admin\"}";
        }
        if ("password".equals(password)) {
            return "{\"msg\":\"登录成功（使用弱密码）\",\"username\":\"" + username + "\",\"password\":\"password\"}";
        }
        if ("abc123".equals(password)) {
            return "{\"msg\":\"登录成功（使用弱密码）\",\"username\":\"" + username + "\",\"password\":\"abc123\"}";
        }
        if ("qwerty".equals(password)) {
            return "{\"msg\":\"登录成功（使用弱密码）\",\"username\":\"" + username + "\",\"password\":\"qwerty\"}";
        }
        
        return "{\"msg\":\"登录失败（密码不匹配或未使用示例弱密码）\"}";
    }

    /**
     * 安全示例：实施密码强度验证（模拟）
     * 安全实践：
     * 1. 拒绝常见弱密码
     * 2. 验证密码复杂度（长度、字符类型）
     * 3. 不在响应中泄露密码信息
     * 4. 实际系统中应使用哈希比较而非明文比较
     */
    @PostMapping("/safe/login")
    public String safeLoginWithPasswordPolicy(
            @RequestParam String username,
            @RequestParam String password) {
        
        // 1. 检查是否为常见弱密码
        if (isCommonWeakPassword(password)) {
            return "{\"msg\":\"登录失败：密码属于常见弱密码，请更换更安全的密码\"}";
        }
        
        // 2. 验证密码强度
        if (!isPasswordStrongEnough(password)) {
            return "{\"msg\":\"登录失败：密码强度不足，要求至少8位，包含大小写字母、数字和特殊字符\"}";
        }
        
        // 3. 实际系统中应使用哈希比较（示例中仅做模拟）
        // 正确做法：String hashedPassword = passwordEncoder.encode(password);
        // 正确做法：if (passwordEncoder.matches(password, storedHashedPassword)) { ... }
        
        return "{\"msg\":\"登录成功（密码符合安全要求）\",\"username\":\"" + username + "\"}";
    }
    
    /**
     * 检查是否为常见弱密码
     */
    private boolean isCommonWeakPassword(String password) {
        // 常见弱密码字典（实际系统中应使用更全面的字典）
        String[] weakPasswords = {
            "123456", "123456789", "12345", "qwerty", "password",
            "12345678", "111111", "123123", "1234567", "admin",
            "1234", "abc123", "qwerty123", "1q2w3e4r", "123qwe"
        };
        
        for (String weak : weakPasswords) {
            if (weak.equals(password)) {
                return true;
            }
        }
        return false;
    }
    
    /**
     * 验证密码强度是否足够
     */
    private boolean isPasswordStrongEnough(String password) {
        // 密码强度要求：至少8位，包含大小写字母、数字和特殊字符
        if (password.length() < 8) {
            return false;
        }
        
        boolean hasUpper = false;
        boolean hasLower = false;
        boolean hasDigit = false;
        boolean hasSpecial = false;
        String specialChars = "!@#$%^&*()_+-=[]{}|;:,.<>?";
        
        for (char c : password.toCharArray()) {
            if (Character.isUpperCase(c)) hasUpper = true;
            else if (Character.isLowerCase(c)) hasLower = true;
            else if (Character.isDigit(c)) hasDigit = true;
            else if (specialChars.contains(String.valueOf(c))) hasSpecial = true;
        }
        
        return hasUpper && hasLower && hasDigit && hasSpecial;
    }
}