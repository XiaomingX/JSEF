package com.freedom.securitysamples.api.corsConfig;

import org.springframework.http.HttpHeaders;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

/**
 * CORS（跨域资源共享）配置安全漏洞示例控制器
 * 说明：CORS是一种浏览器安全机制，用于控制不同源之间的资源访问。
 *       不当的CORS配置会导致跨域攻击，使恶意网站能够访问敏感数据或执行未授权操作。
 * 常见风险：
 * 1. 敏感数据泄露（如用户信息、认证令牌）
 * 2. 跨站请求伪造（CSRF）攻击加剧
 * 3. 未授权的跨域操作（如修改数据、执行操作）
 * 4. 绕过同源策略限制
 * 修复原则：
 * 1. 最小权限原则：仅允许必要的源、方法和头部
 * 2. 严格验证：不直接信任请求中的Origin头，使用白名单验证
 * 3. 谨慎使用凭证：当允许credentials时，禁止使用Access-Control-Allow-Origin: *
 * 4. 限制预检请求缓存时间：避免过长的Max-Age导致配置变更延迟生效
 * 5. 禁止使用无效通配符：Origin头部不支持部分通配符（如*.example.com）
 */
@RestController
@RequestMapping("/security-example/cors")
public class CorsVulnerabilityController {

    /**
     * 不安全示例1：允许所有源访问
     * 漏洞点：使用Access-Control-Allow-Origin: * 允许任何域名跨域访问
     * 风险：
     * - 恶意网站可通过浏览器获取本接口返回的敏感数据
     * - 绕过浏览器同源策略限制，导致数据泄露
     * 修复建议：仅允许明确信任的源，而非所有源
     */
    @GetMapping("/unsafe/allow-all-origins")
    public ResponseEntity<String> unsafeAllowAllOrigins() {
        HttpHeaders headers = new HttpHeaders();
        // 危险配置：允许所有源访问
        headers.add("Access-Control-Allow-Origin", "*");
        return ResponseEntity.ok()
                .headers(headers)
                .body("不安全的CORS配置：允许所有源访问（*）");
    }

    /**
     * 不安全示例2：直接信任请求中的Origin头
     * 漏洞点：将请求头中的Origin直接作为允许的源返回
     * 风险：
     * - 攻击者可伪造任意Origin头，绕过跨域限制
     * - 恶意网站可伪装成信任源，获取敏感信息
     * 修复建议：使用白名单验证Origin，仅允许预定义的可信源
     */
    @GetMapping("/unsafe/trust-request-origin")
    public ResponseEntity<String> unsafeTrustRequestOrigin(@RequestHeader("Origin") String origin) {
        HttpHeaders headers = new HttpHeaders();
        // 危险配置：直接信任并返回请求中的Origin
        headers.add("Access-Control-Allow-Origin", origin);
        return ResponseEntity.ok()
                .headers(headers)
                .body("不安全的CORS配置：直接信任请求中的Origin头");
    }

    /**
     * 不安全示例3：宽松的凭证与源配置
     * 漏洞点：允许来自不安全源的带凭证请求
     * 风险：
     * - 当Access-Control-Allow-Credentials为true时，若源不可信，会导致敏感cookie泄露
     * - 恶意网站可利用用户的身份凭证执行操作
     * 修复建议：仅对可信源启用凭证支持，且不使用通配符源
     */
    @GetMapping("/unsafe/loose-credentials")
    public ResponseEntity<String> unsafeLooseCredentials() {
        HttpHeaders headers = new HttpHeaders();
        // 危险配置：允许来自不安全源的凭证请求
        headers.add("Access-Control-Allow-Origin", "http://unsafe-site.com");
        headers.add("Access-Control-Allow-Credentials", "true");
        headers.add("Access-Control-Allow-Methods", "*"); // 允许所有HTTP方法
        return ResponseEntity.ok()
                .headers(headers)
                .body("不安全的CORS配置：宽松的凭证与方法限制");
    }

    /**
     * 不安全示例4：无效的通配符使用
     * 漏洞点：在Origin中使用部分通配符（浏览器不支持），导致配置失效或意外允许访问
     * 风险：
     * - 部分通配符（如*.example.com）在CORS中不被标准支持，可能被浏览器忽略
     * - 错误的头部配置可能导致实际允许所有源访问
     * 修复建议：使用精确的源白名单，或通过服务器逻辑验证子域名
     */
    @GetMapping("/unsafe/invalid-wildcard")
    public ResponseEntity<String> unsafeInvalidWildcard() {
        HttpHeaders headers = new HttpHeaders();
        // 危险配置：使用不被支持的部分通配符
        headers.add("Access-Control-Allow-Origin", "*.example.com");
        headers.add("Access-Control-Allow-Headers", "*"); // 允许所有请求头
        return ResponseEntity.ok()
                .headers(headers)
                .body("不安全的CORS配置：使用无效的部分通配符");
    }

    /**
     * 不安全示例5：敏感操作的不当CORS配置
     * 漏洞点：对包含敏感操作的接口允许所有源访问
     * 风险：
     * - 恶意网站可诱导用户执行敏感操作（如修改数据、提交表单）
     * - 结合CSRF攻击可造成严重后果
     * 修复建议：敏感操作接口应严格限制源，甚至禁止跨域访问
     */
    @PostMapping("/unsafe/sensitive-operation")
    public ResponseEntity<String> unsafeSensitiveOperation() {
        HttpHeaders headers = new HttpHeaders();
        // 危险配置：对POST等敏感操作允许所有源
        headers.add("Access-Control-Allow-Origin", "*");
        headers.add("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE");
        headers.add("Access-Control-Allow-Headers", "Authorization");
        return ResponseEntity.ok()
                .headers(headers)
                .body("不安全的CORS配置：敏感操作接口允许所有源");
    }

    /**
     * 不安全示例6：不当的预检请求配置
     * 漏洞点：预检请求允许所有源且缓存时间过长
     * 风险：
     * - 过长的Max-Age（如10小时）会导致CORS配置变更后延迟生效
     * - 允许所有源的预检响应会被缓存，扩大攻击窗口
     * 修复建议：合理设置Max-Age（如300秒），并严格限制允许的源和方法
     */
    @RequestMapping(value = "/unsafe/preflight-config", method = RequestMethod.OPTIONS)
    public ResponseEntity<String> unsafePreflightConfig() {
        HttpHeaders headers = new HttpHeaders();
        // 危险配置：预检请求允许所有源且缓存时间过长
        headers.add("Access-Control-Allow-Origin", "*");
        headers.add("Access-Control-Max-Age", "36000000"); // 10小时缓存
        headers.add("Access-Control-Allow-Methods", "GET,POST,PUT,DELETE");
        return ResponseEntity.ok()
                .headers(headers)
                .body("不安全的CORS配置：不当的预检请求设置");
    }

    /**
     * 不安全示例7：错误的多源配置方式
     * 漏洞点：通过逗号分隔多个源，这不符合CORS标准
     * 风险：
     * - CORS标准要求Access-Control-Allow-Origin只能是单个源或*
     * - 逗号分隔的多源会被浏览器视为无效，导致跨域请求被拒绝或意外允许
     * 修复建议：通过服务器逻辑验证请求Origin是否在白名单中，只返回匹配的单个源
     */
    @GetMapping("/unsafe/multiple-origins")
    public ResponseEntity<String> unsafeMultipleOrigins() {
        HttpHeaders headers = new HttpHeaders();
        // 危险配置：使用逗号分隔多个源（不符合CORS标准）
        headers.add("Access-Control-Allow-Origin", "http://site1.com, http://site2.com");
        return ResponseEntity.ok()
                .headers(headers)
                .body("不安全的CORS配置：错误的多源配置方式");
    }
}
