package com.freedom.securitysamples.api.RiskyOperations;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import sun.misc.Unsafe;
import java.rmi.Naming;
import java.rmi.Remote;
import java.rmi.RemoteException;
import java.lang.reflect.Field;

/**
 * 不安全操作漏洞示例控制器
 * 说明：本类展示两种高风险操作的不安全用法：
 * 1. sun.misc.Unsafe：绕过JVM安全机制直接操作内存/线程/对象，可能导致内存损坏、JVM崩溃或远程代码执行
 * 2. RMI（远程方法调用）：配置或使用不当可能导致远程命令执行、信息泄露等风险
 * 安全警示：生产环境中严禁直接使用Unsafe类；RMI需严格限制访问权限并启用安全机制
 */
@RestController
@RequestMapping("/security-example/unsafe-operations")
public class UnsafeOperationsVulnerabilityController {

    // sun.misc.Unsafe实例（本身是不安全的API，仅用于演示）
    private static final Unsafe unsafe;

    static {
        try {
            // 通过反射获取Unsafe实例（正常情况下不允许直接访问）
            Field unsafeField = Unsafe.class.getDeclaredField("theUnsafe");
            unsafeField.setAccessible(true); // 破坏封装性，绕过访问控制
            unsafe = (Unsafe) unsafeField.get(null);
        } catch (Exception e) {
            throw new RuntimeException("获取Unsafe实例失败（演示用）", e);
        }
    }

    /**
     * 不安全示例1：通过Unsafe读取任意内存地址
     * 漏洞点：允许用户指定内存地址并直接读取，可导致敏感信息泄露（如密码、密钥）
     * 风险后果：读取操作系统内核地址可能导致程序崩溃，甚至触发系统级漏洞
     */
    @GetMapping("/unsafe/read-memory")
    public String unsafeReadMemory(@RequestParam(required = false) String memoryAddressInput) {
        if (memoryAddressInput != null) {
            try {
                // 将用户输入转换为内存地址（危险：用户可指定任意地址）
                long targetAddress = Long.parseLong(memoryAddressInput);
                // 直接读取指定内存地址的值（绕过JVM内存保护）
                int memoryValue = unsafe.getInt(targetAddress);
                return "{\"status\":\"danger\",\"message\":\"成功读取内存地址值（不安全操作）\",\"data\":" + memoryValue + "}";
            } catch (NumberFormatException e) {
                return "{\"status\":\"error\",\"message\":\"内存地址格式无效（必须为数字）\"}";
            } catch (Exception e) {
                return "{\"status\":\"error\",\"message\":\"读取内存地址失败（可能触发保护机制）\"}";
            }
        }
        return "{\"status\":\"error\",\"message\":\"请提供内存地址参数\"}";
    }

    /**
     * 不安全示例2：通过Unsafe直接分配内存
     * 漏洞点：分配的内存不受JVM垃圾回收管控，容易导致内存泄漏或耗尽系统内存
     * 风险场景：恶意用户可反复调用分配大量内存，导致服务拒绝响应（DoS）
     */
    @GetMapping("/unsafe/allocate-memory")
    public String unsafeAllocateMemory(@RequestParam(required = false) Long memorySize) {
        if (memorySize != null && memorySize > 0) {
            try {
                // 直接分配原生内存（不受JVM堆大小限制）
                long allocatedAddress = unsafe.allocateMemory(memorySize);
                return "{\"status\":\"danger\",\"message\":\"成功分配原生内存（未受JVM管控）\",\"data\":\"内存地址：" + allocatedAddress + "\"}";
            } catch (Exception e) {
                return "{\"status\":\"error\",\"message\":\"内存分配失败（可能超出系统限制）\"}";
            }
        }
        return "{\"status\":\"error\",\"message\":\"内存大小必须为正数\"}";
    }

    /**
     * 不安全示例3：通过Unsafe释放内存
     * 漏洞点：释放错误地址可能导致内存损坏、程序崩溃或数据 corruption
     * 风险细节：重复释放同一地址（double free）是典型的内存漏洞，可能被利用执行恶意代码
     */
    @GetMapping("/unsafe/free-memory")
    public String unsafeFreeMemory(@RequestParam(required = false) Long memoryAddress) {
        if (memoryAddress != null) {
            try {
                // 直接释放指定地址内存（无校验机制）
                unsafe.freeMemory(memoryAddress);
                return "{\"status\":\"danger\",\"message\":\"已尝试释放指定地址内存（可能破坏内存完整性）\"}";
            } catch (Exception e) {
                return "{\"status\":\"error\",\"message\":\"内存释放失败（地址可能无效）\"}";
            }
        }
        return "{\"status\":\"error\",\"message\":\"请提供有效的内存地址\"}";
    }

    /**
     * 不安全示例4：通过Unsafe创建未初始化对象
     * 漏洞点：跳过构造函数直接创建对象，导致对象处于不一致状态（如未初始化的字段）
     * 风险影响：破坏面向对象封装性，可能绕过对象内部校验逻辑，引发业务逻辑漏洞
     */
    @GetMapping("/unsafe/create-uninitialized-object")
    public String unsafeCreateUninitializedObject(@RequestParam(required = false) String dataInput) {
        if (dataInput != null) {
            try {
                // 跳过构造函数创建对象（对象可能处于无效状态）
                DummyObject uninitializedObj = (DummyObject) unsafe.allocateInstance(DummyObject.class);
                uninitializedObj.setData(dataInput); // 直接修改字段，绕过可能的构造函数校验
                return "{\"status\":\"danger\",\"message\":\"已创建未初始化对象（跳过构造函数）\",\"data\":\"" + uninitializedObj + "\"}";
            } catch (InstantiationException e) {
                return "{\"status\":\"error\",\"message\":\"对象创建失败\"}";
            }
        }
        return "{\"status\":\"error\",\"message\":\"请提供数据参数\"}";
    }

    /**
     * 不安全示例5：通过Unsafe执行CAS（Compare-And-Swap）操作
     * 漏洞点：对任意内存地址执行CAS操作，可能破坏原子性或篡改关键数据
     * 风险场景：恶意修改线程状态、锁标识等，导致并发逻辑混乱或死锁
     */
    @GetMapping("/unsafe/cas-operation")
    public String unsafeCompareAndSwap(
            @RequestParam(required = false) Long targetAddress,
            @RequestParam(required = false) Integer expectedValue,
            @RequestParam(required = false) Integer newValue) {
        if (targetAddress != null && expectedValue != null && newValue != null) {
            try {
                // 对任意地址执行CAS操作（无权限校验）
                boolean isSuccess = unsafe.compareAndSwapInt(null, targetAddress, expectedValue, newValue);
                return "{\"status\":\"danger\",\"message\":\"CAS操作执行完成（可能破坏数据原子性）\",\"data\":\"操作" + (isSuccess ? "成功" : "失败") + "\"}";
            } catch (Exception e) {
                return "{\"status\":\"error\",\"message\":\"CAS操作失败\"}";
            }
        }
        return "{\"status\":\"error\",\"message\":\"地址、预期值、新值均为必填参数\"}";
    }

    /**
     * 不安全示例6：通过Unsafe向任意内存地址写入数据
     * 漏洞点：直接修改内存数据，可篡改程序关键变量、函数指针等
     * 极端风险：在特定场景下可能修改JVM内部状态，导致远程代码执行（RCE）
     */
    @GetMapping("/unsafe/write-memory")
    public String unsafeWriteMemory(
            @RequestParam(required = false) Long targetAddress,
            @RequestParam(required = false) Integer valueToWrite) {
        if (targetAddress != null && valueToWrite != null) {
            try {
                // 直接向指定内存地址写入数据（覆盖原有数据）
                unsafe.putInt(targetAddress, valueToWrite);
                return "{\"status\":\"danger\",\"message\":\"已向内存地址写入数据（可能破坏程序完整性）\"}";
            } catch (Exception e) {
                return "{\"status\":\"error\",\"message\":\"写入内存失败（地址可能受保护）\"}";
            }
        }
        return "{\"status\":\"error\",\"message\":\"内存地址和写入值均为必填参数\"}";
    }

    /**
     * 不安全示例7：通过Unsafe挂起线程
     * 漏洞点：强制挂起线程可能导致线程池耗尽、服务无响应
     * 攻击场景：恶意用户反复调用挂起关键线程（如处理请求的线程），造成DoS攻击
     */
    @GetMapping("/unsafe/park-thread")
    public String unsafeParkThread(@RequestParam(required = false) Long delayMillis) {
        if (delayMillis != null && delayMillis > 0) {
            try {
                // 挂起当前线程指定时间（绕过线程管理机制）
                unsafe.park(false, delayMillis * 1000000); // 转换为纳秒
                return "{\"status\":\"danger\",\"message\":\"线程已挂起指定时间（可能导致服务延迟）\"}";
            } catch (Exception e) {
                return "{\"status\":\"error\",\"message\":\"线程挂起失败\"}";
            }
        }
        return "{\"status\":\"error\",\"message\":\"延迟时间必须为正数（毫秒）\"}";
    }

    /**
     * 不安全示例8：通过Unsafe唤醒线程
     * 漏洞点：无控制地唤醒线程可能破坏线程同步逻辑，导致数据竞争
     * 风险后果：可能引发并发问题（如脏读、数据不一致），难以调试
     */
    @GetMapping("/unsafe/unpark-thread")
    public String unsafeUnparkThread() {
        try {
            Thread currentThread = Thread.currentThread();
            // 强制唤醒指定线程（可能打乱原有同步逻辑）
            unsafe.unpark(currentThread);
            return "{\"status\":\"danger\",\"message\":\"线程已被强制唤醒（可能破坏并发控制）\"}";
        } catch (Exception e) {
            return "{\"status\":\"error\",\"message\":\"线程唤醒失败\"}";
        }
    }

    /**
     * 不安全示例9：RMI远程方法调用（未做安全限制）
     * 漏洞点：未验证输入且RMI配置不安全，可能导致远程命令执行
     * 历史风险：RMI曾被多次曝出反序列化漏洞（如CVE-2017-3241），恶意序列化数据可触发攻击
     */
    @GetMapping("/rmi/call-remote-service")
    public String unsafeRmiCall(@RequestParam String userInput) {
        try {
            // 连接到本地RMI服务（实际场景中若连接不可信服务风险更高）
            RemoteService remoteService = (RemoteService) Naming.lookup("rmi://localhost:1099/RemoteService");
            // 将用户输入直接传递给远程服务（无过滤，可能触发远程端漏洞）
            String response = remoteService.processInput(userInput);
            return "{\"status\":\"danger\",\"message\":\"RMI调用完成（输入未验证）\",\"data\":\"" + response + "\"}";
        } catch (Exception e) {
            return "{\"status\":\"error\",\"message\":\"RMI调用失败：" + e.getMessage() + "\"}";
        }
    }

    /**
     * RMI服务接口定义（仅用于演示）
     */
    public interface RemoteService extends Remote {
        String processInput(String input) throws RemoteException;
    }

    /**
     * 演示用的 dummy 对象类
     */
    static class DummyObject {
        private String data; // 未初始化时可能为null，导致后续操作异常

        public void setData(String data) {
            this.data = data;
        }

        @Override
        public String toString() {
            return "DummyObject{data='" + data + "'}";
        }
    }
}
    