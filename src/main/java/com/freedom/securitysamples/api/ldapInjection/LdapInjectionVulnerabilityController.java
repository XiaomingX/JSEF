package com.freedom.securitysamples.api.ldapInjection;

import org.springframework.web.bind.annotation.*;
import javax.naming.*;
import javax.naming.directory.*;
import java.util.Hashtable;

/**
 * LDAP注入漏洞示例控制器
 * 说明：LDAP注入是攻击者通过在输入中插入恶意LDAP语法，操纵LDAP查询或认证过程的攻击方式。
 *       LDAP（轻量级目录访问协议）常用于用户认证和信息查询，注入攻击可能导致未授权访问、
 *       敏感信息泄露或权限提升。
 * 常见风险：
 * 1. 绕过身份验证机制
 * 2. 未授权访问敏感目录信息
 * 3. 执行未授权的LDAP操作
 * 4. 泄露用户信息或组织结构
 * 修复原则：
 * 1. 对所有用户输入进行严格验证和过滤
 * 2. 使用LDAP查询构建工具或参数化查询
 * 3. 限制LDAP服务账号的权限
 * 4. 避免直接拼接用户输入到LDAP查询或DN中
 * 5. 采用白名单机制验证输入内容
 */
@RestController
@RequestMapping("/security-example/ldap-injection")
public class LdapInjectionVulnerabilityController {

    /**
     * 不安全示例：直接使用用户输入构建DN和搜索过滤器
     * 漏洞点：
     * 1. 将用户输入直接拼接至LDAP区分名(DN)中
     * 2. 将用户输入直接用于构建搜索过滤器
     * 攻击示例：
     * 用户输入为 "example.com)(objectClass=*)"
     * 构造的DN变为 "OU=People,O=example.com)(objectClass=*)"
     * 构造的过滤器变为 "username=example.com)(objectClass=*)"
     * 风险：攻击者可获取所有对象的信息，绕过原本的查询限制
     */
    @GetMapping("/unsafe/direct-input-usage")
    public String unsafeSearchWithDirectInput(@RequestParam String userInput) throws NamingException {
        Hashtable<String, String> ldapEnvironment = new Hashtable<>();
        ldapEnvironment.put(Context.INITIAL_CONTEXT_FACTORY, "com.sun.jndi.ldap.LdapCtxFactory");
        ldapEnvironment.put(Context.PROVIDER_URL, "ldap://localhost:389");

        InitialDirContext ldapContext = new InitialDirContext(ldapEnvironment);

        // 不安全: 未经过滤的用户输入直接用于DN构建
        String distinguishedName = "OU=People,O=" + userInput;

        // 不安全: 未经过滤的用户输入直接用于搜索过滤器
        String searchFilter = "username=" + userInput;

        ldapContext.search(distinguishedName, searchFilter, new SearchControls());
        return "{'msg':'search completed'}";
    }

    /**
     * 不安全示例：在LDAP认证过程中使用未过滤的用户输入
     * 漏洞点：将用户输入直接拼接至安全主体(DN)中用于认证
     * 攻击示例：
     * 用户名输入为 "admin)(!userPassword=*)"
     * 构造的安全主体变为 "cn=admin)(!userPassword=*),dc=example,dc=com"
     * 这会构造一个永远为真的条件，绕过密码验证
     * 风险：攻击者可无需正确密码即可通过认证，获取未授权访问权限
     */
    @PostMapping("/unsafe/auth-with-user-input")
    public String unsafeAuthentication(@RequestParam String username, @RequestParam String password) throws NamingException {
        Hashtable<String, String> env = new Hashtable<>();
        env.put(Context.INITIAL_CONTEXT_FACTORY, "com.sun.jndi.ldap.LdapCtxFactory");
        env.put(Context.PROVIDER_URL, "ldap://localhost:389");

        // 不安全: 未经过滤的用户输入直接用于绑定DN
        env.put(Context.SECURITY_PRINCIPAL, "cn=" + username + ",dc=example,dc=com");
        env.put(Context.SECURITY_CREDENTIALS, password);

        // 如果注入成功，即使密码错误也能通过认证
        new InitialDirContext(env);
        return "{'msg':'authentication successful'}";
    }

    /**
     * 不安全示例：在复杂查询条件中使用用户输入
     * 漏洞点：在多条件组合的LDAP过滤器中直接拼接用户输入
     * 攻击示例：
     * 部门输入为 "IT)(title=*)"
     * 构造的过滤器变为 "(&(department=IT)(title=*))(title=manager))"
     * 这会返回所有IT部门的用户，而非仅IT部门的经理
     * 风险：攻击者可获取超出权限范围的信息，绕过查询限制
     */
    @GetMapping("/unsafe/complex-filter-with-input")
    public String unsafeComplexSearch(@RequestParam String dept, @RequestParam String title) throws NamingException {
        InitialDirContext ctx = getLdapContext();

        // 不安全: 在复杂的过滤条件中直接使用用户输入
        String filter = "(&(department=" + dept + ")(title=" + title + "))";

        ctx.search("dc=example,dc=com", filter, new SearchControls());
        return "{'msg':'complex search completed'}";
    }

    /**
     * 不安全示例：动态构建搜索基础DN
     * 漏洞点：使用用户输入动态构建LDAP搜索的基础DN
     * 攻击示例：
     * 组织输入为 "example,dc=com)(objectClass=*)"
     * 国家输入为 "cn"
     * 构造的基础DN变为 "o=example,dc=com)(objectClass=*),c=cn"
     * 风险：攻击者可改变搜索范围，访问其他目录树的信息
     */
    @GetMapping("/unsafe/dynamic-base-dn")
    public String unsafeDynamicBaseDN(@RequestParam String country, @RequestParam String org) throws NamingException {
        InitialDirContext ctx = getLdapContext();

        // 不安全: 动态构建基础DN时直接使用用户输入
        String baseDN = String.format("o=%s,c=%s", org, country);

        ctx.search(baseDN, "(objectClass=person)", new SearchControls());
        return "{'msg':'dynamic base DN search completed'}";
    }

    /**
     * 不安全示例：批量操作中使用未过滤的用户输入
     * 漏洞点：在循环处理的批量操作中，直接使用用户输入构建过滤器
     * 攻击示例：
     * 其中一个用户ID输入为 "123)(objectClass=user)"
     * 构造的过滤器变为 "(uid=123)(objectClass=user))"
     * 风险：单个恶意输入会影响整个批量操作，导致查询范围扩大
     */
    @PostMapping("/unsafe/batch-operation")
    public String unsafeBatchOperation(@RequestParam String[] userIds) throws NamingException {
        InitialDirContext ctx = getLdapContext();

        for(String userId : userIds) {
            // 不安全: 批量操作中直接使用用户输入
            String filter = "(uid=" + userId + ")";
            ctx.search("dc=example,dc=com", filter, new SearchControls());
        }
        return "{'msg':'batch operation completed'}";
    }

    /**
     * 不安全示例：动态属性查询中使用用户输入
     * 漏洞点：允许用户指定查询的属性名和属性值，且未做过滤
     * 攻击示例：
     * 属性名输入为 "objectClass"
     * 属性值输入为 "*"
     * 构造的过滤器变为 "(objectClass=*)"
     * 风险：攻击者可查询任意属性，获取敏感信息或系统元数据
     */
    @GetMapping("/unsafe/dynamic-attribute-query")
    public String unsafeAttributeQuery(@RequestParam String attrName, @RequestParam String attrValue) throws NamingException {
        InitialDirContext ctx = getLdapContext();

        // 不安全: 动态构建属性查询时直接使用用户输入
        String filter = "(" + attrName + "=" + attrValue + ")";

        ctx.search("dc=example,dc=com", filter, new SearchControls());
        return "{'msg':'attribute query completed'}";
    }

    /**
     * 获取LDAP上下文的辅助方法
     */
    private InitialDirContext getLdapContext() throws NamingException {
        Hashtable<String, String> env = new Hashtable<>();
        env.put(Context.INITIAL_CONTEXT_FACTORY, "com.sun.jndi.ldap.LdapCtxFactory");
        env.put(Context.PROVIDER_URL, "ldap://localhost:389");
        return new InitialDirContext(env);
    }
}