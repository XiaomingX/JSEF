package com.freedom.securitysamples.api.crossSiteScripting;

import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

/**
 * 跨站脚本（XSS）漏洞示例控制器
 * 说明：XSS（Cross-Site Scripting）是一种注入型漏洞，攻击者通过在网页中注入恶意JavaScript代码，
 *       当用户访问受影响页面时，恶意代码会在用户浏览器中执行，从而窃取信息、劫持会话或发起进一步攻击。
 * XSS漏洞分类：
 * 1. 反射型XSS：恶意代码通过URL参数等方式传入，即时反射到页面中执行（非持久化）
 * 2. 存储型XSS：恶意代码被存储到服务器（如数据库、评论区），所有访问该页面的用户都会触发（持久化）
 * 3. DOM型XSS：通过操纵页面DOM结构触发，恶意代码不经过服务器端处理
 * 常见风险：
 * 1. 窃取用户Cookie、Session ID，劫持用户会话
 * 2. 伪造用户操作，执行未授权行为（如转账、修改密码）
 * 3. 弹出钓鱼窗口，诱导用户输入敏感信息
 * 4. 植入恶意脚本（如挖矿脚本、木马）
 * 修复原则：
 * 1. 输入验证：对用户输入的特殊字符（如<、>、"、'、&）进行严格过滤
 * 2. 输出转义：根据输出场景（HTML、JS、JSON、URL）使用对应的转义规则
 * 3. 使用安全框架：如Spring MVC的自动转义、React/Vue的模板安全机制
 * 4. 开启CSP（内容安全策略）：限制浏览器加载和执行脚本的来源
 * 5. 避免使用内联事件处理器（如onclick、onload）和eval()等危险API
 */
@RestController
@RequestMapping("/security-example/cross-site-scripting")
public class CrossSiteScriptingVulnerabilityController {

    /**
     * 不安全示例：直接返回用户输入（反射型XSS）
     * 漏洞点：未对用户输入做任何转义，直接将输入内容作为响应返回
     * 风险：攻击者注入的JavaScript代码会被浏览器直接执行
     * 示例攻击输入：<script>alert('窃取Cookie：' + document.cookie)</script>
     * 触发场景：用户点击包含恶意输入的URL后，脚本在当前页面执行
     */
    @GetMapping("/unsafe/direct-return")
    public String unsafeDirectReturnUserInput(@RequestParam("userInput") String userInput) {
        // 危险实践：用户输入直接作为响应内容返回，无任何转义处理
        return userInput;
    }

    /**
     * 不安全示例：HTML内容直接拼接（反射型XSS）
     * 漏洞点：将用户输入直接拼接到HTML标签中，未转义HTML特殊字符
     * 风险：攻击者可闭合原有HTML标签，注入新的恶意标签（如<script>）
     * 示例攻击输入：'"><script>alert('XSS注入HTML')</script><div class="'
     * 攻击后HTML：<div>Welcome, '"><script>alert('XSS注入HTML')</script><div class="'!</div>
     */
    @GetMapping("/unsafe/html-concatenation")
    public String unsafeHtmlContentConcatenation(@RequestParam("userName") String userName) {
        // 危险实践：HTML标签与用户输入直接拼接，未转义<、>、"、'等特殊字符
        return "<div>Welcome, " + userName + "!</div>";
    }

    /**
     * 不安全示例：JavaScript代码直接拼接（反射型XSS）
     * 漏洞点：将用户输入直接嵌入到<script>标签内，成为JS代码的一部分
     * 风险：攻击者可注入任意JS逻辑，如窃取页面数据、调用后端接口
     * 示例攻击输入：alert('注入JS代码：' + document.querySelector('body').innerHTML);
     * 攻击后JS：<script>alert('注入JS代码：' + document.querySelector('body').innerHTML);</script>
     */
    @GetMapping("/unsafe/script-concatenation")
    public String unsafeScriptContentConcatenation(@RequestParam("jsCode") String jsCode) {
        // 危险实践：用户输入直接作为JavaScript代码执行，完全信任不可信输入
        return "<script>" + jsCode + "</script>";
    }

    /**
     * 不安全示例：URL参数直接嵌入（反射型XSS）
     * 漏洞点：将用户输入直接作为<a>标签的href属性值，未验证URL合法性
     * 风险：攻击者可注入"javascript:"伪协议，执行JS代码（而非跳转URL）
     * 示例攻击输入：javascript:alert('点击链接触发XSS')
     * 攻击后HTML：<a href='javascript:alert('点击链接触发XSS')'>Click here</a>
     * 触发场景：用户点击该链接时，浏览器执行伪协议中的JS代码
     */
    @GetMapping("/unsafe/url-embedding")
    public String unsafeUrlParameterEmbedding(@RequestParam("targetUrl") String targetUrl) {
        // 危险实践：未验证URL协议（如禁止javascript:、data:等伪协议），直接作为href属性
        return "<a href='" + targetUrl + "'>Click here</a>";
    }

    /**
     * 不安全示例：JSON数据直接输出（反射型XSS）
     * 漏洞点：将用户输入直接拼接到JSON字符串中，未转义双引号和特殊字符
     * 风险：攻击者可破坏JSON结构，注入JS代码（若前端直接将JSON作为HTML渲染）
     * 示例攻击输入："';alert('JSON注入')//
     * 攻击后JSON：{"userInput":"'";alert('JSON注入')//"}
     * 触发场景：前端若用eval()解析该JSON，或直接插入页面，会执行注入的JS
     */
    @GetMapping("/unsafe/json-output")
    public String unsafeJsonContentOutput(@RequestParam("jsonData") String jsonData) {
        // 危险实践：JSON字符串与用户输入直接拼接，未转义双引号、反斜杠等JSON特殊字符
        return "{\"userInput\":\"" + jsonData + "\"}";
    }

    /**
     * 不安全示例：模板渲染未转义（反射型/存储型XSS）
     * 漏洞点：模板引擎未开启HTML自动转义，直接渲染用户输入的内容
     * 风险：若模板中用${message}直接输出，注入的恶意标签会被解析执行
     * 示例攻击输入：<img src=x onerror=alert('模板XSS')>
     * 触发场景：用户访问包含该模板的页面，img标签加载失败时执行onerror事件中的JS
     * 说明：假设模板文件template.html中存在未转义的变量渲染（如Thymeleaf未加th:text）
     */
    @GetMapping("/unsafe/template-rendering")
    public String unsafeTemplateRendering(Model model, @RequestParam("userMessage") String userMessage) {
        // 危险实践：将用户输入直接传入模板，若模板未开启自动转义则触发XSS
        model.addAttribute("message", userMessage);
        return "template"; // 模板文件需配合，此处模拟未转义的渲染场景
    }

    /**
     * 不安全示例：CSS样式注入（反射型XSS）
     * 漏洞点：将用户输入直接拼接到HTML元素的style属性中，未过滤特殊字符
     * 风险：攻击者可闭合style属性，注入内联事件处理器（如onmouseover）
     * 示例攻击输入：red';onmouseover='alert('CSS注入触发')'
     * 攻击后HTML：<div style='color:red';onmouseover='alert('CSS注入触发')'>Colored text</div>
     * 触发场景：用户鼠标移到该div上时，执行onmouseover中的JS代码
     */
    @GetMapping("/unsafe/css-injection")
    public String unsafeCssStyleInjection(@RequestParam("colorValue") String colorValue) {
        // 危险实践：style属性与用户输入直接拼接，未过滤分号、引号等可注入字符
        return "<div style='color:" + colorValue + "'>Colored text</div>";
    }

    /**
     * 不安全示例：图片标签属性注入（反射型XSS）
     * 漏洞点：将用户输入直接作为<img>标签的src属性，未验证资源合法性
     * 风险：攻击者可注入无效src值，通过onerror事件执行JS代码
     * 示例攻击输入：x' onerror='alert('图片注入XSS')' alt='
     * 攻击后HTML：<img src='x' onerror='alert('图片注入XSS')' alt='' />
     * 触发场景：图片src加载失败（如"x"不是有效路径），触发onerror事件
     */
    @GetMapping("/unsafe/image-tag-injection")
    public String unsafeImageTagInjection(@RequestParam("imageSrc") String imageSrc) {
        // 危险实践：img标签的src属性直接使用用户输入，未过滤事件处理器和特殊字符
        return "<img src='" + imageSrc + "' />";
    }

    /**
     * 不安全示例：iframe内容注入（反射型XSS）
     * 漏洞点：将用户输入直接作为iframe的srcdoc属性值，srcdoc支持HTML内容渲染
     * 风险：攻击者可在iframe中注入完整的恶意HTML/JS，实现隔离的攻击环境
     * 示例攻击输入：<script>parent.alert('iframe注入，影响父页面')</script>
     * 攻击后HTML：<iframe srcdoc='<script>parent.alert('iframe注入，影响父页面')</script>'></iframe>
     * 说明：srcdoc属性会将输入解析为iframe内部的HTML，恶意脚本可通过parent访问父页面
     */
    @GetMapping("/unsafe/iframe-injection")
    public String unsafeIframeContentInjection(@RequestParam("iframeContent") String iframeContent) {
        // 危险实践：iframe的srcdoc属性直接使用用户输入，允许注入完整HTML结构
        return "<iframe srcdoc='" + iframeContent + "'></iframe>";
    }

    /**
     * 不安全示例：事件处理器注入（反射型XSS）
     * 漏洞点：将用户输入直接作为HTML元素的内联事件处理器（如onclick）
     * 风险：攻击者可注入任意JS代码，通过用户交互（如点击按钮）触发
     * 示例攻击输入：alert('点击按钮触发：' + document.URL);
     * 攻击后HTML：<button onclick='alert('点击按钮触发：' + document.URL);'>Click me</button>
     * 触发场景：用户点击该按钮时，执行onclick中的恶意JS
     */
    @GetMapping("/unsafe/event-handler-injection")
    public String unsafeEventHandlerInjection(@RequestParam("eventCode") String eventCode) {
        // 危险实践：内联事件处理器直接使用用户输入，违背"避免内联脚本"的安全原则
        return "<button onclick='" + eventCode + "'>Click me</button>";
    }
}