package com.freedom.securitysamples.api.onglInjection;

import ognl.Ognl;
import ognl.OgnlException;
import org.springframework.web.bind.annotation.*;

/**
 * OGNL注入漏洞示例控制器
 * 说明：OGNL（Object-Graph Navigation Language）是一种表达式语言，若直接使用用户可控输入构建表达式并执行，
 * 会导致远程代码执行（RCE）、文件操作、反射调用等严重安全漏洞。
 * 安全风险：攻击者可通过构造恶意OGNL表达式，执行系统命令、读写文件、调用任意类方法，甚至控制整个应用。
 * 修复建议：1. 严禁使用用户输入直接拼接或作为OGNL表达式执行 2. 若必须使用表达式，采用严格白名单限制允许的操作 3. 使用沙箱机制禁用危险类/方法（如Runtime、File）
 */
@RestController
@RequestMapping("/security-example/ognl")
public class OgnlInjectionVulnerabilityController {

    /**
     * 不安全示例：直接执行用户提供的OGNL表达式
     * 漏洞点：将用户输入的表达式直接解析执行，无任何过滤或限制
     * 攻击示例：传入 "@java.lang.Runtime@getRuntime().exec('calc.exe')" 可执行计算器
     * 危害：攻击者可通过表达式调用任意Java类和方法，完全控制应用服务器
     */
    @GetMapping("/unsafe/evaluate-raw")
    public String unsafeEvaluateRawOgnl(@RequestParam String userControlledOgnlExpression) throws OgnlException {
        // 危险操作：直接解析并执行用户提供的OGNL表达式
        Ognl.getValue(Ognl.parseExpression(userControlledOgnlExpression), null);
        return "{\"status\":\"用户提供的OGNL表达式已执行（存在严重风险）\"}";
    }

    /**
     * 不安全示例：拼接用户输入执行系统命令
     * 漏洞点：将用户输入的命令直接拼接到OGNL表达式中，构造Runtime.exec调用
     * 攻击示例：传入 "calc.exe" 会执行计算器，传入 "rm -rf /" 可能删除系统文件（视权限而定）
     * 原理：OGNL支持通过@类名@方法名调用静态方法，直接拼接用户输入会导致命令注入
     */
    @GetMapping("/unsafe/exec-command")
    public String unsafeExecuteSystemCommand(@RequestParam String userInputCommand) throws OgnlException {
        // 危险拼接：用户输入直接嵌入到执行命令的OGNL表达式中
        String maliciousOgnlExpression = "@java.lang.Runtime@getRuntime().exec('" + userInputCommand + "')";
        // 执行恶意表达式
        Ognl.getValue(Ognl.parseExpression(maliciousOgnlExpression), null);
        return "{\"status\":\"系统命令已执行（存在RCE风险）\"}";
    }

    /**
     * 不安全示例：拼接用户输入进行文件操作
     * 漏洞点：用户输入的文件路径直接拼接到表达式，构造File操作
     * 攻击示例：传入 "/etc/passwd" 可删除敏感系统文件（视权限而定）
     * 危害：可能导致文件被删除、篡改或敏感信息泄露
     */
    @PostMapping("/unsafe/manipulate-file")
    public String unsafeFileManipulation(@RequestParam String userInputFilePath) throws OgnlException {
        // 危险拼接：用户提供的路径直接用于构建文件删除表达式
        String maliciousOgnlExpression = "new java.io.File('" + userInputFilePath + "').delete()";
        Ognl.getValue(Ognl.parseExpression(maliciousOgnlExpression), null);
        return "{\"status\":\"文件操作已执行（可能导致数据丢失）\"}";
    }

    /**
     * 不安全示例：拼接类名和方法名进行反射调用
     * 漏洞点：用户输入的类名和方法名直接拼接到表达式，允许调用任意静态方法
     * 攻击示例：传入类名"java.lang.Runtime"和方法名"getRuntime().exec('calc.exe')"可执行命令
     * 风险放大：完全开放反射调用会导致应用逻辑被绕过，敏感操作被执行
     */
    @GetMapping("/unsafe/reflective-call")
    public String unsafeReflectiveMethodCall(
            @RequestParam String userInputClassName,
            @RequestParam String userInputMethodName) throws OgnlException {
        // 危险拼接：用户输入直接用于构建反射调用表达式
        String maliciousOgnlExpression = "@" + userInputClassName + "@" + userInputMethodName + "()";
        Ognl.getValue(Ognl.parseExpression(maliciousOgnlExpression), null);
        return "{\"status\":\"反射方法调用已执行（存在权限绕过风险）\"}";
    }

    /**
     * 不安全示例：实例化用户指定的类
     * 漏洞点：用户输入的类名直接用于创建对象，可能实例化危险类
     * 攻击示例：传入 "java.io.FileOutputStream" 并结合其他操作可写入恶意文件
     * 原理：OGNL允许通过new关键字实例化类，恶意类可能包含危险初始化逻辑
     */
    @GetMapping("/unsafe/instantiate-object")
    public String unsafeObjectInstantiation(@RequestParam String userInputClassName) throws OgnlException {
        // 危险操作：使用用户输入的类名实例化对象
        String maliciousOgnlExpression = "new " + userInputClassName + "()";
        Ognl.getValue(Ognl.parseExpression(maliciousOgnlExpression), null);
        return "{\"status\":\"对象已实例化（可能创建危险实例）\"}";
    }

    /**
     * 不安全示例：调用系统类的静态方法
     * 漏洞点：用户输入直接拼接到系统类（java.lang.System）的方法调用中
     * 攻击示例：传入 "exit(0)" 可导致应用进程退出，传入 "getProperty('user.home')" 可泄露敏感信息
     * 危害：可能导致服务中断、敏感系统属性泄露
     */
    @GetMapping("/unsafe/call-system-static")
    public String unsafeCallSystemStaticMethod(@RequestParam String userInputMethod) throws OgnlException {
        // 危险拼接：用户输入直接作为System类的方法调用
        String maliciousOgnlExpression = "@java.lang.System@" + userInputMethod;
        Ognl.getValue(Ognl.parseExpression(maliciousOgnlExpression), null);
        return "{\"status\":\"系统类静态方法已调用（存在信息泄露或服务中断风险）\"}";
    }
}
    