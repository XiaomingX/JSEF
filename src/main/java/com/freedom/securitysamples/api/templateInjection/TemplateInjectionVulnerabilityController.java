package com.freedom.securitysamples.api.templateInjection;

import org.springframework.web.bind.annotation.*;
import freemarker.template.Configuration;
import freemarker.template.Template;
import freemarker.template.TemplateException;
import org.thymeleaf.TemplateEngine;
import org.thymeleaf.context.Context;
import org.thymeleaf.templateresolver.StringTemplateResolver;
import org.apache.velocity.VelocityContext;
import org.apache.velocity.app.VelocityEngine;

import freemarker.core.TemplateClassResolver;

import java.io.File;
import java.io.IOException;
import java.io.StringReader;
import java.io.StringWriter;
import java.util.HashMap;
import java.util.Map;
import java.util.Properties;

/**
 * 模板注入漏洞示例控制器
 * 说明：模板注入是指攻击者通过构造恶意输入控制模板内容或模板解析过程，
 *       导致模板引擎执行非预期代码，可能引发远程代码执行、敏感信息泄露等严重安全问题。
 * 常见风险：
 * 1. 远程代码执行（最严重，可控制服务器）
 * 2. 敏感系统信息泄露（如系统变量、配置信息）
 * 3. 权限提升或越权访问
 * 4. 数据篡改或破坏
 * 修复原则：
 * 1. 禁止用户输入直接作为模板内容或模板路径
 * 2. 使用安全的模板引擎配置（限制类加载、表达式执行权限）
 * 3. 对用户输入进行严格验证和转义
 * 4. 使用预定义模板，仅允许用户输入作为数据而非模板逻辑
 * 5. 最小权限原则配置模板引擎
 */
@RestController
@RequestMapping("/security-example/template-injection")
public class TemplateInjectionVulnerabilityController {

    /**
     * 不安全示例：直接使用用户输入作为FreeMarker模板内容
     * 漏洞点：将用户输入完整作为模板内容解析执行
     * 风险：攻击者可注入FreeMarker表达式执行任意代码
     * 示例攻击输入：${"".getClass().forName("java.lang.Runtime").getMethod("getRuntime").invoke(null).exec("calc")}
     * 攻击后果：在服务器上执行计算器程序（实际可执行任意系统命令）
     */
    @GetMapping("/unsafe/freemarker-direct-input")
    public String unsafeFreeMarkerDirectInput(@RequestParam String userInput) {
        try {
            Configuration cfg = new Configuration(Configuration.VERSION_2_3_31);
            // 危险实践：直接将用户输入作为模板内容
            Template template = new Template("userTemplate",
                    new StringReader(userInput),
                    cfg);

            Map<String, Object> dataModel = new HashMap<>();
            dataModel.put("user", "admin");
            dataModel.put("role", "administrator");

            StringWriter writer = new StringWriter();
            template.process(dataModel, writer);

            return writer.toString();

        } catch (IOException | TemplateException e) {
            return "模板处理错误: " + e.getMessage();
        }
    }

    /**
     * 不安全示例：Thymeleaf模板直接处理用户输入
     * 漏洞点：将用户输入作为Thymeleaf模板内容解析
     * 风险：攻击者可利用Thymeleaf表达式注入执行恶意代码
     * 示例攻击输入：[[${T(java.lang.Runtime).getRuntime().exec('calc')}]]
     * 攻击原理：Thymeleaf的[[...]]语法会解析并执行表达式
     */
    @GetMapping("/unsafe/thymeleaf-direct-input")
    public String unsafeThymeleafDirectInput(@RequestParam String userInput) {
        TemplateEngine templateEngine = new TemplateEngine();
        StringTemplateResolver templateResolver = new StringTemplateResolver();
        templateEngine.setTemplateResolver(templateResolver);

        Context context = new Context();
        context.setVariable("user", "admin");

        // 危险实践：直接使用用户输入作为模板内容
        return templateEngine.process(userInput, context);
    }

    /**
     * 不安全示例：Velocity模板直接处理用户输入
     * 漏洞点：将用户输入作为Velocity模板解析执行
     * 风险：攻击者可注入Velocity表达式执行系统命令或访问敏感信息
     * 示例攻击输入：#set($x= $context.get("ognl.OgnlContext").getClass().forName("java.lang.Runtime").getMethod("getRuntime").invoke(null).exec("calc"))
     * 攻击原理：利用Velocity的模板语法执行任意代码
     */
    @GetMapping("/unsafe/velocity-direct-input")
    public String unsafeVelocityDirectInput(@RequestParam String userInput) {
        try {
            VelocityEngine velocityEngine = new VelocityEngine();
            Properties props = new Properties();
            props.put("runtime.log.logsystem.class", "org.apache.velocity.runtime.log.NullLogSystem");
            velocityEngine.init(props);

            VelocityContext context = new VelocityContext();
            context.put("user", "admin");

            StringWriter writer = new StringWriter();
            // 危险实践：直接将用户输入作为模板内容
            velocityEngine.evaluate(context, writer, "userTemplate", userInput);

            return writer.toString();
        } catch (Exception e) {
            return "Velocity模板处理错误: " + e.getMessage();
        }
    }

    /**
     * 不安全示例：用户控制模板文件路径
     * 漏洞点：允许用户输入直接指定模板加载目录
     * 风险：路径遍历攻击，可读取服务器任意文件或执行恶意模板
     * 示例攻击输入：../../../../etc （Linux系统下可能读取系统配置文件）
     * 攻击后果：攻击者可访问服务器敏感文件或执行预存的恶意模板
     */
    @GetMapping("/unsafe/template-path-control")
    public String unsafeTemplatePathControl(@RequestParam String templatePath) {
        try {
            Configuration cfg = new Configuration(Configuration.VERSION_2_3_31);
            // 危险实践：用户输入直接控制模板加载路径
            cfg.setDirectoryForTemplateLoading(new File(templatePath));
            Template template = cfg.getTemplate("template.ftl");

            Map<String, Object> dataModel = new HashMap<>();
            dataModel.put("user", "admin");

            StringWriter writer = new StringWriter();
            template.process(dataModel, writer);

            return writer.toString();
        } catch (Exception e) {
            return "模板处理错误: " + e.getMessage();
        }
    }

    /**
     * 不安全示例：模板内容中拼接用户输入
     * 漏洞点：将用户输入直接拼接进模板内容，形成动态模板逻辑
     * 风险：攻击者可通过输入构造模板表达式执行恶意代码
     * 示例攻击输入：user.getRole()}${"".getClass().forName("java.lang.Runtime")...
     * 攻击原理：拼接后形成完整的恶意表达式被模板引擎执行
     */
    @GetMapping("/unsafe/template-string-concat")
    public String unsafeTemplateStringConcat(@RequestParam String userName) {
        try {
            Configuration cfg = new Configuration(Configuration.VERSION_2_3_31);
            // 危险实践：在模板内容中直接拼接用户输入
            String templateContent = "Hello ${" + userName + "}!";
            Template template = new Template("userTemplate",
                    new StringReader(templateContent),
                    cfg);

            Map<String, Object> dataModel = new HashMap<>();
            StringWriter writer = new StringWriter();
            template.process(dataModel, writer);

            return writer.toString();
        } catch (Exception e) {
            return "模板处理错误: " + e.getMessage();
        }
    }

    /**
     * 不安全示例：模板引擎配置不当
     * 漏洞点：使用允许加载任意类的不安全配置
     * 风险：即使模板内容受控，宽松的配置也会放大攻击危害
     * 安全配置说明：
     * - TemplateClassResolver.ALLOWS_NOTHING_RESOLVER: 禁止所有类访问（最安全）
     * - TemplateClassResolver.SAFER_RESOLVER: 限制危险类访问（较安全）
     * - 自定义 resolver: 仅允许指定安全包的类（按需配置）
     */
    @GetMapping("/unsafe/unsafe-engine-config")
    public String unsafeEngineConfig(@RequestParam String userInput) {
        try {
            Configuration cfg = new Configuration(Configuration.VERSION_2_3_31);

            // 危险配置：允许加载所有类（默认配置可能更宽松）
            // 注意：此处代码展示了不安全配置，实际开发应使用SAFER_RESOLVER或更严格的配置
            cfg.setNewBuiltinClassResolver(TemplateClassResolver.ALLOWS_NOTHING_RESOLVER);

            // 安全配置示例（应使用下面的配置）：
            // cfg.setNewBuiltinClassResolver(TemplateClassResolver.SAFER_RESOLVER);

            Template template = new Template("userTemplate",
                    new StringReader(userInput),
                    cfg);

            Map<String, Object> dataModel = new HashMap<>();
            StringWriter writer = new StringWriter();
            template.process(dataModel, writer);

            return writer.toString();
        } catch (Exception e) {
            return "模板处理错误: " + e.getMessage();
        }
    }

    /**
     * 安全示例：模板注入防护实现
     * 安全措施：
     * 1. 使用安全的模板引擎配置（限制类加载）
     * 2. 使用预定义模板，禁止用户输入作为模板内容
     * 3. 对用户输入进行严格转义处理
     * 4. 模板文件从安全目录加载，路径不可控
     */
    @GetMapping("/safe/secure-template-processing")
    public String secureTemplateProcessing(@RequestParam String userInput) {
        try {
            Configuration cfg = new Configuration(Configuration.VERSION_2_3_31);

            // 安全配置：限制类加载，防止通过模板调用危险类
            cfg.setNewBuiltinClassResolver(TemplateClassResolver.SAFER_RESOLVER);

            // 安全实践：从固定的安全目录加载预定义模板
            cfg.setClassForTemplateLoading(this.getClass(), "/templates");

            // 安全实践：使用预定义模板，而非用户输入的动态模板
            Template template = cfg.getTemplate("secure_template.ftl");

            // 安全实践：用户输入仅作为数据模型，且经过转义处理
            Map<String, Object> dataModel = new HashMap<>();
            dataModel.put("sanitizedUserInput", sanitizeUserInput(userInput));

            StringWriter writer = new StringWriter();
            template.process(dataModel, writer);

            return writer.toString();
        } catch (Exception e) {
            return "模板处理错误: " + e.getMessage();
        }
    }

    /**
     * 辅助方法：用户输入安全处理
     * 功能：对用户输入进行转义，防止注入攻击
     * 转义规则：处理模板引擎特殊字符和HTML特殊字符
     */
    private String sanitizeUserInput(String input) {
        if (input == null) {
            return "";
        }
        // 1. 转义模板引擎特殊字符
        String sanitized = input.replace("$", "\\$")
                                .replace("#", "\\#")
                                .replace("@", "\\@")
                                .replace("{", "\\{")
                                .replace("}", "\\}");
        
        // 2. 转义HTML特殊字符，防止XSS
        sanitized = sanitized.replace("<", "&lt;")
                             .replace(">", "&gt;")
                             .replace("\"", "&quot;")
                             .replace("'", "&#39;")
                             .replace("&", "&amp;");
                             
        return sanitized;
    }
}
