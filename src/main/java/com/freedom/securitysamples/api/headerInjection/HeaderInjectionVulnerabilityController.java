package com.freedom.securitysamples.api.headerInjection;

import org.springframework.http.HttpHeaders;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

/**
 * HTTP头注入漏洞示例控制器
 * 说明：HTTP头注入是指攻击者通过构造恶意输入，篡改或新增HTTP响应头，从而绕过安全防护、实施钓鱼、窃取数据等攻击。
 * 核心原理：当服务器将用户可控输入直接拼接进HTTP头时，攻击者可利用换行符（\r\n）、回车符等特殊字符拆分头部，
 *          注入额外的恶意HTTP头（如Set-Cookie、X-XSS-Protection）或篡改原有头的语义。
 * 常见风险：
 * 1. 开放重定向：恶意重定向至钓鱼网站
 * 2. 跨域信息泄露：不当CORS配置导致敏感数据被窃取
 * 3. Cookie劫持：注入恶意Cookie覆盖合法会话
 * 4. 内容解析绕过：篡改Content-Type导致安全策略失效
 * 5. 点击劫持防护失效：篡改X-Frame-Options等防护头
 * 修复原则：
 * 1. 输入严格验证：对头部相关输入进行格式校验（如URL白名单、合法字符集限制）
 * 2. 过滤特殊字符：禁止\r\n、\n、\t等控制字符，防止头部拆分
 * 3. 使用安全API：优先使用框架提供的头部构造工具（如ContentDispositionBuilder），避免直接字符串拼接
 * 4. 白名单机制：对Content-Type、CORS Origin、X-Frame-Options等关键头使用预定义白名单
 */
@RestController
@RequestMapping("/security-example/header-injection")
public class HeaderInjectionVulnerabilityController {

    /**
     * 不安全示例：直接注入自定义HTTP头
     * 漏洞点：将未过滤的用户输入直接作为X-Custom-Header的值
     * 风险：攻击者可注入换行符拆分头部，新增恶意头（如Set-Cookie、X-XSS-Protection）
     * 示例攻击输入："normal-value\r\nSet-Cookie: session=hacked-session-id; Path=/"
     * 攻击后响应头：
     * X-Custom-Header: normal-value
     * Set-Cookie: session=hacked-session-id; Path=/  // 注入的恶意Cookie
     */
    @GetMapping("/unsafe/custom-header")
    public ResponseEntity<String> unsafeAddCustomHeader(@RequestParam String untrustedHeaderValue) {
        HttpHeaders headers = new HttpHeaders();
        // 危险实践：直接拼接未过滤的用户输入作为头部值
        headers.add("X-Custom-Header", untrustedHeaderValue);
        return ResponseEntity
                .ok()
                .headers(headers)
                .body("Response with potentially injected custom header");
    }

    /**
     * 不安全示例：开放重定向（Location头注入）
     * 漏洞点：将用户输入直接作为Location头的值，未验证重定向目标
     * 风险：诱导用户跳转至钓鱼网站，窃取账号密码等敏感信息
     * 示例攻击输入："https://malicious-phish.com/login?fake=1"
     * 攻击后响应头：
     * Location: https://malicious-phish.com/login?fake=1  // 恶意重定向目标
     */
    @GetMapping("/unsafe/open-redirect")
    public ResponseEntity<String> unsafeOpenRedirect(@RequestParam String untrustedRedirectUrl) {
        HttpHeaders headers = new HttpHeaders();
        // 危险实践：允许任意URL作为重定向目标，无白名单校验
        headers.add("Location", untrustedRedirectUrl);
        return ResponseEntity
                .status(302)  // 302临时重定向
                .headers(headers)
                .body("Redirecting to untrusted target...");
    }

    /**
     * 不安全示例：Cookie注入（Set-Cookie头拼接）
     * 漏洞点：直接将用户输入拼接进Set-Cookie头，未过滤特殊字符
     * 风险：攻击者可注入分号（;）新增恶意Cookie属性，或注入换行符新增其他头
     * 示例攻击输入："user=attacker; session=hijacked-id\r\nX-Malicious: payload"
     * 攻击后响应头：
     * Set-Cookie: userdata=user=attacker; session=hijacked-id  // 注入额外Cookie属性
     * X-Malicious: payload  // 注入的恶意头
     */
    @GetMapping("/unsafe/set-cookie")
    public ResponseEntity<String> unsafeSetCookieWithUnsanitizedValue(@RequestParam String untrustedCookieData) {
        HttpHeaders headers = new HttpHeaders();
        // 危险实践：直接拼接用户输入构建Set-Cookie头，未使用安全的Cookie构造API
        headers.add("Set-Cookie", "userdata=" + untrustedCookieData);
        return ResponseEntity
                .ok()
                .headers(headers)
                .body("Cookie set with untrusted data");
    }

    /**
     * 不安全示例：下载文件名注入（Content-Disposition头）
     * 漏洞点：下载文件名直接使用用户输入，未过滤换行符和特殊字符
     * 风险：注入恶意头或导致文件名解析异常，甚至触发XSS（部分浏览器对文件名处理不当）
     * 示例攻击输入："malicious.exe\r\nSet-Cookie: session=hacked; Path=/\r\nX-XSS: <script>steal()</script>"
     * 攻击后响应头：
     * Content-Disposition: attachment; filename=malicious.exe
     * Set-Cookie: session=hacked; Path=/  // 注入的恶意Cookie
     * X-XSS: <script>steal()</script>  // 注入的XSS payload
     */
    @GetMapping("/unsafe/download-filename")
    public ResponseEntity<String> unsafeSetDownloadFileName(@RequestParam String untrustedFileName) {
        HttpHeaders headers = new HttpHeaders();
        // 危险实践：直接拼接用户输入作为下载文件名，未过滤特殊字符
        headers.add("Content-Disposition", "attachment; filename=" + untrustedFileName);
        return ResponseEntity
                .ok()
                .headers(headers)
                .body("Downloading file with untrusted name...");
    }

    /**
     * 不安全示例：Content-Type头注入
     * 漏洞点：允许用户输入任意Content-Type，未做合法性校验
     * 风险：绕过内容安全策略（CSP）、诱导浏览器解析恶意内容（如将文本解析为HTML触发XSS）
     * 示例攻击输入："text/html; charset=utf-8\r\nSet-Cookie: bad=1; Path=/"
     * 攻击后响应头：
     * Content-Type: text/html; charset=utf-8  // 篡改内容类型
     * Set-Cookie: bad=1; Path=/  // 注入的恶意Cookie
     */
    @GetMapping("/unsafe/set-content-type")
    public ResponseEntity<String> unsafeSetContentType(@RequestParam String untrustedContentType) {
        HttpHeaders headers = new HttpHeaders();
        // 危险实践：允许任意Content-Type，无白名单限制（如仅允许text/plain、application/json等）
        headers.add("Content-Type", untrustedContentType);
        return ResponseEntity
                .ok()
                .headers(headers)
                .body("Response with untrusted Content-Type");
    }

    /**
     * 不安全示例：CORS配置注入（Access-Control-Allow-Origin）
     * 漏洞点：将用户输入直接作为CORS允许的源（Origin），未限制合法域名
     * 风险：攻击者控制的网站可跨域请求当前服务，窃取敏感数据（如用户信息、会话）
     * 示例攻击输入："https://attacker-controlled-site.com"
     * 攻击后响应头：
     * Access-Control-Allow-Origin: https://attacker-controlled-site.com  // 允许恶意网站跨域访问
     */
    @GetMapping("/unsafe/set-cors-origin")
    public ResponseEntity<String> unsafeSetCorsOrigin(@RequestParam String untrustedOrigin) {
        HttpHeaders headers = new HttpHeaders();
        // 危险实践：允许任意Origin跨域访问，未使用白名单（如仅允许https://trusted-domain.com）
        headers.add("Access-Control-Allow-Origin", untrustedOrigin);
        return ResponseEntity
                .ok()
                .headers(headers)
                .body("CORS response with untrusted origin");
    }

    /**
     * 不安全示例：WWW-Authenticate头注入
     * 漏洞点：认证 Realm 值直接使用用户输入，未过滤特殊字符
     * 风险：注入换行符新增恶意头，或篡改认证提示信息诱导用户输入凭证
     * 示例攻击输入："Fake Login\r\nSet-Cookie: session=hacked-realm; Path=/"
     * 攻击后响应头：
     * WWW-Authenticate: Basic realm="Fake Login"  // 篡改认证提示
     * Set-Cookie: session=hacked-realm; Path=/  // 注入的恶意Cookie
     */
    @GetMapping("/unsafe/set-auth-realm")
    public ResponseEntity<String> unsafeSetAuthRealm(@RequestParam String untrustedRealmValue) {
        HttpHeaders headers = new HttpHeaders();
        // 危险实践：直接拼接用户输入作为认证Realm，未过滤换行符
        headers.add("WWW-Authenticate", "Basic realm=\"" + untrustedRealmValue + "\"");
        return ResponseEntity
                .status(401)  // 401未授权，触发认证弹窗
                .headers(headers)
                .body("Authentication required with untrusted realm");
    }

    /**
     * 不安全示例：Refresh头注入（自动刷新/重定向）
     * 漏洞点：Refresh头的目标URL直接使用用户输入，未验证合法性
     * 风险：自动跳转到恶意网站，或注入换行符新增其他恶意头
     * 示例攻击输入："5; url=https://phish-site.com/steal\r\nSet-Cookie: session=stolen; Path=/"
     * 攻击后响应头：
     * Refresh: 5; url=https://phish-site.com/steal  // 5秒后自动跳转至钓鱼网站
     * Set-Cookie: session=stolen; Path=/  // 注入的恶意Cookie
     */
    @GetMapping("/unsafe/set-refresh-header")
    public ResponseEntity<String> unsafeSetRefreshHeader(@RequestParam String untrustedRefreshTarget) {
        HttpHeaders headers = new HttpHeaders();
        // 危险实践：直接拼接用户输入作为Refresh头的目标，无URL校验
        headers.add("Refresh", "5; url=" + untrustedRefreshTarget);
        return ResponseEntity
                .ok()
                .headers(headers)
                .body("Page will refresh to untrusted target after 5 seconds...");
    }

    /**
     * 不安全示例：X-Frame-Options头注入（点击劫持防护绕过）
     * 漏洞点：X-Frame-Options值直接使用用户输入，未限制合法选项
     * 风险：绕过点击劫持防护（如设置无效值ALLOWALL），或注入恶意头
     * 示例攻击输入："ALLOW-FROM https://attacker.com\r\nSet-Cookie: malicious=1; Path=/"
     * 攻击后响应头：
     * X-Frame-Options: ALLOW-FROM https://attacker.com  // 允许恶意网站嵌套当前页面（点击劫持）
     * Set-Cookie: malicious=1; Path=/  // 注入的恶意Cookie
     */
    @GetMapping("/unsafe/set-x-frame-options")
    public ResponseEntity<String> unsafeSetXFrameOptions(@RequestParam String untrustedFrameValue) {
        HttpHeaders headers = new HttpHeaders();
        // 危险实践：允许任意X-Frame-Options值，未使用预定义合法值（DENY、SAMEORIGIN等）
        headers.add("X-Frame-Options", untrustedFrameValue);
        return ResponseEntity
                .ok()
                .headers(headers)
                .body("X-Frame-Options set with untrusted value");
    }

    /**
     * 不安全示例：多HTTP头组合注入
     * 漏洞点：多个头部（X-Custom-Header、Cache-Control）均使用未过滤的用户输入
     * 风险：攻击面扩大，可同时注入多个恶意头，造成叠加危害
     * 示例攻击输入：
     * - untrustedCustomValue: "test\r\nSet-Cookie: c1=hacked1; Path=/"
     * - untrustedCacheValue: "no-store\r\nSet-Cookie: c2=hacked2; Path=/"
     * 攻击后响应头：
     * X-Custom-Header: test
     * Set-Cookie: c1=hacked1; Path=/  // 第一个注入的Cookie
     * Cache-Control: no-store
     * Set-Cookie: c2=hacked2; Path=/  // 第二个注入的Cookie
     */
    @GetMapping("/unsafe/set-multiple-headers")
    public ResponseEntity<String> unsafeSetMultipleHeaders(
            @RequestParam String untrustedCustomValue,
            @RequestParam String untrustedCacheValue) {
        HttpHeaders headers = new HttpHeaders();
        // 危险实践：多个头部均直接使用未过滤输入，风险叠加
        headers.add("X-Custom-Header", untrustedCustomValue);
        headers.add("Cache-Control", untrustedCacheValue);
        return ResponseEntity
                .ok()
                .headers(headers)
                .body("Multiple headers set with untrusted data");
    }
}