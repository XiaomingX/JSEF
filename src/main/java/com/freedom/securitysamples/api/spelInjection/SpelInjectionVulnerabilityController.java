package com.freedom.securitysamples.api.spelInjection;

import org.springframework.expression.Expression;
import org.springframework.expression.ExpressionParser;
import org.springframework.expression.spel.standard.SpelExpression;
import org.springframework.expression.spel.standard.SpelExpressionParser;
import org.springframework.expression.spel.support.SimpleEvaluationContext;
import org.springframework.expression.spel.support.StandardEvaluationContext;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import jakarta.el.ELProcessor;

import java.util.HashMap;
import java.util.Map;

/**
 * SpEL（Spring Expression Language）注入漏洞示例控制器
 * 说明：SpEL是Spring框架的表达式语言，若直接使用用户可控输入作为表达式执行，会导致远程代码执行（RCE）
 * 安全风险：攻击者可构造恶意表达式调用系统类（如Runtime）执行命令、访问敏感数据或破坏系统
 * 防御核心：
 * 1. 避免使用用户输入直接构造SpEL表达式
 * 2. 优先使用SimpleEvaluationContext限制表达式权限（禁止类型引用、方法调用等）
 * 3. 对必须使用的用户输入实施严格白名单验证
 * 4. 采用参数化表达式（通过变量传递用户输入，而非直接拼接）
 */
@RestController
@RequestMapping("/security-example/spel")
public class SpelInjectionVulnerabilityController {
    // SpEL表达式解析器实例（全局共享）
    private static final ExpressionParser spelParser = new SpelExpressionParser();

    /**
     * 不安全示例1：直接解析并执行用户输入的SpEL表达式
     * 漏洞点：使用parseExpression()处理用户输入，且未限制表达式上下文
     * 攻击示例：用户输入 "#{T(java.lang.Runtime).getRuntime().exec('calc.exe')}" 可执行计算器
     */
    @GetMapping("/unsafe/direct-eval")
    public String unsafeSpelDirectEvaluation(@RequestParam String userControlledInput) {
        // 解析用户提供的表达式（危险：无任何过滤）
        Expression spelExpression = spelParser.parseExpression(userControlledInput);
        // 执行表达式并获取结果（攻击者可通过表达式执行任意代码）
        Object result = spelExpression.getValue();
        return "{\"status\":\"表达式执行完成（存在安全风险）\", \"result\":\"" + String.valueOf(result).replace("\"", "\\\"") + "\"}";
        
    }

    /**
     * 不安全示例2：使用parseRaw()解析用户输入的原始表达式
     * 漏洞点：parseRaw()允许解析不包含#{...}的原始表达式，风险与直接解析一致
     * 攻击示例：用户输入 "T(java.lang.Runtime).getRuntime().exec('notepad.exe')" 可打开记事本
     */
    @GetMapping("/unsafe/raw-eval")
    public String unsafeSpelRawEvaluation(@RequestParam String userControlledInput) {
        // 解析原始表达式（无需#{...}包裹，直接执行用户输入）
        SpelExpression spelExpression = ((SpelExpressionParser) spelParser).parseRaw(userControlledInput);
        // 执行恶意表达式
        spelExpression.getValue();
        return "{\"status\":\"原始表达式执行完成（存在安全风险）\"}";
    }

    /**
     * 不安全示例3：复用解析器执行用户表达式（无上下文限制）
     * 漏洞点：即使复用解析器实例，只要使用用户输入作为表达式，仍存在注入风险
     * 风险本质：漏洞源于"用户输入直接作为表达式"，与解析器是否复用无关
     */
    @GetMapping("/unsafe/reused-parser-eval")
    public String unsafeSpelReusedParser(@RequestParam String userControlledInput) {
        Expression spelExpression = spelParser.parseExpression(userControlledInput);
        // 执行表达式（存在SpEL注入风险）
        spelExpression.getValue();
        return "{\"status\":\"复用解析器执行完成（存在安全风险）\"}";
    }

    /**
     * 不安全示例4：链式调用解析并执行用户表达式
     * 漏洞点：链式调用只是代码风格差异，未改变"用户输入直接作为表达式"的风险本质
     */
    @GetMapping("/unsafe/chain-eval")
    public String unsafeSpelChainEvaluation(@RequestParam String userControlledInput) {
        // 链式调用解析并执行表达式（同样危险）
        Expression spelExpression = new SpelExpressionParser().parseExpression(userControlledInput);
        spelExpression.getValue();
        return "{\"status\":\"链式调用执行完成（存在安全风险）\"}";
    }

    /**
     * 不安全示例5：使用用户表达式修改对象属性
     * 漏洞点：通过setValue()执行用户表达式，可篡改目标对象状态或触发危险操作
     * 攻击场景：攻击者可注入表达式修改系统关键对象的属性（如权限、配置等）
     */
    @GetMapping("/unsafe/expression-set-value")
    public String unsafeSpelSetValue(@RequestParam String userControlledInput) {
        Expression spelExpression = new SpelExpressionParser().parseExpression(userControlledInput);
        
        Object targetObject = new Object(); // 目标对象（实际场景可能是业务对象）
        Object newValue = new Object();
        // 危险操作：使用用户表达式设置对象值
        spelExpression.setValue(targetObject, newValue);
        return "{\"status\":\"表达式赋值操作完成（存在安全风险）\"}";
    }

    /**
     * 不安全示例6：通过表达式获取值类型信息
     * 漏洞点：即使仅获取值类型，表达式仍可能执行恶意代码
     * 原理：SpEL在解析类型时会执行表达式逻辑，而非单纯的类型检查
     */
    @GetMapping("/unsafe/get-value-type")
    public String unsafeSpelGetValueTypeId(@RequestParam String userControlledInput) {
        Expression spelExpression = spelParser.parseExpression(userControlledInput);
        // 获取值类型时仍会执行表达式（存在注入风险）
        Class<?> valueType = spelExpression.getValueType();
        return "{\"status\":\"获取值类型完成（存在安全风险），类型：" + valueType + "\"}";
    }

    /**
     * 不安全示例7：使用StandardEvaluationContext执行用户表达式
     * 漏洞点：StandardEvaluationContext默认允许访问所有类和方法，无安全限制
     * 风险放大：该上下文支持更多高级特性，被注入后危害更大
     */
    @GetMapping("/unsafe/standard-context-eval")
    public String unsafeSpelStandardContext(@RequestParam String userControlledInput) {
        Expression spelExpression = spelParser.parseExpression(userControlledInput);
        // 标准上下文（无安全限制）
        StandardEvaluationContext evaluationContext = new StandardEvaluationContext();
        // 在全权限上下文中执行用户表达式（高度危险）
        spelExpression.getValue(evaluationContext);
        return "{\"status\":\"标准上下文执行完成（存在安全风险）\"}";
    }

    /**
     * 不安全示例8：变量中使用用户输入（直接引用变量）
     * 漏洞点：虽然通过变量传递输入，但表达式直接引用变量，若变量内容被拼接进表达式仍有风险
     * 攻击示例：用户输入包含SpEL表达式片段，可能被其他场景拼接后执行
     */
    @GetMapping("/unsafe/variable-direct-reference")
    public String unsafeSpelVariableDirectUse(@RequestParam String userControlledInput) {
        StandardEvaluationContext context = new StandardEvaluationContext();
        // 将用户输入设为变量
        context.setVariable("userInput", userControlledInput);
        // 直接引用变量（若变量内容包含恶意表达式片段，存在风险）
        Expression spelExpression = spelParser.parseExpression("#userInput");
        String result = spelExpression.getValue(context).toString();
        return "{\"result\":\"" + result + "\"（变量引用存在安全风险）";
    }

    /**
     * 不安全示例9：方法调用中使用用户输入
     * 漏洞点：用户输入作为对象属性被调用，若输入包含特殊字符可能触发表达式解析
     */
    @GetMapping("/unsafe/method-call-with-input")
    public String unsafeSpelMethodCall(@RequestParam String userControlledInput) {
        Map<String, Object> contextMap = new HashMap<>();
        // 将用户输入存入Map
        contextMap.put("userInput", userControlledInput);
        
        StandardEvaluationContext context = new StandardEvaluationContext();
        context.setRootObject(contextMap);
        
        // 调用用户输入的toString()（看似安全，但若输入被拼接进表达式则危险）
        Expression spelExpression = spelParser.parseExpression("userInput.toString()");
        String result = spelExpression.getValue(context).toString();
        return "{\"result\":\"" + result + "\"（方法调用存在潜在风险）";
    }

    /**
     * 不安全示例10：EL表达式注入（与SpEL类似的表达式语言风险）
     * 漏洞点：ELProcessor.eval()直接执行用户输入，可导致类似RCE漏洞
     * 说明：EL（Expression Language）与SpEL不同，但同样存在表达式注入风险
     */
    @GetMapping("/unsafe/el-eval")
    public String unsafeElEvaluation(@RequestParam String userControlledInput) {
        ELProcessor elProcessor = new ELProcessor();
        String result;
        try {
            // 直接执行用户输入的EL表达式（危险）
            result = (String) elProcessor.eval(userControlledInput);
        } catch (Exception e) {
            result = "表达式执行错误: " + e.getMessage();
        }
        return "{\"el_result\":\"" + result + "\"（存在EL注入风险）";
    }

    /**
     * 不安全示例11：在类型引用中拼接用户输入
     * 漏洞点：用户输入被拼接进"T(...)", 可构造恶意类名执行代码
     * 攻击示例：用户输入 "java.lang.Runtime"，表达式变为"T(java.lang.Runtime).getRuntime().exec('calc')"
     */
    @GetMapping("/unsafe/type-reference-injection")
    public String unsafeSpelTypeReference(@RequestParam String userControlledInput) {
        // 危险拼接：用户输入直接嵌入类型引用
        String maliciousExpression = "T(" + userControlledInput + ")";
        Expression spelExpression = spelParser.parseExpression(maliciousExpression);
        String result = spelExpression.getValue().toString();
        return "{\"result\":\"" + result + "\"（类型引用存在注入风险）";
    }

    /**
     * 不安全示例12：在系统属性访问中使用用户输入
     * 漏洞点：用户输入拼接进系统属性访问表达式，可读取敏感配置
     * 攻击示例：用户输入 "user.password" 可获取系统用户密码（若有访问权限）
     */
    @GetMapping("/unsafe/system-property-access")
    public String unsafeSpelSystemProperty(@RequestParam String userControlledInput) {
        StandardEvaluationContext context = new StandardEvaluationContext();
        // 危险拼接：用户输入直接作为系统属性键
        String expression = "@systemProperties['" + userControlledInput + "']";
        Expression spelExpression = spelParser.parseExpression(expression);
        String result = spelExpression.getValue(context).toString();
        return "{\"system_property\":\"" + result + "\"（系统属性访问存在风险）";
    }

    /**
     * 不安全示例13：在列表表达式中使用用户输入
     * 漏洞点：用户输入被拼接进列表表达式，可注入恶意代码
     * 攻击示例：用户输入 "1, T(java.lang.Runtime).getRuntime().exec('calc')" 执行命令
     */
    @GetMapping("/unsafe/list-expression-injection")
    public String unsafeSpelListExpression(@RequestParam String userControlledInput) {
        // 危险拼接：用户输入直接嵌入列表表达式
        String expression = "{" + userControlledInput + "}";
        Expression spelExpression = spelParser.parseExpression(expression);
        String result = spelExpression.getValue().toString();
        return "{\"list_result\":\"" + result + "\"（列表表达式存在注入风险）";
    }

    /**
     * 不安全示例14：在运算符表达式中使用用户输入
     * 漏洞点：用户输入作为运算符被拼接，可构造恶意表达式
     * 攻击示例：用户输入 "+ T(java.lang.Runtime).getRuntime().exec('calc')" 执行命令
     */
    @GetMapping("/unsafe/operator-injection")
    public String unsafeSpelOperatorInjection(@RequestParam String userControlledInput) {
        // 危险拼接：用户输入作为运算符嵌入表达式
        String expression = "2 " + userControlledInput + " 2";
        Expression spelExpression = spelParser.parseExpression(expression);
        String result = spelExpression.getValue().toString();
        return "{\"calculation_result\":\"" + result + "\"（运算符拼接存在风险）";
    }

    /**
     * 安全示例1：使用SimpleEvaluationContext限制表达式权限
     * 安全措施：
     * 1. SimpleEvaluationContext仅允许基本数据绑定，禁止类型引用（T(...)）和方法调用
     * 2. 限制表达式能力，从根本上防止执行系统命令
     */
    @GetMapping("/safe/limited-context")
    public String safeSpelLimitedContext(@RequestParam String userInput) {
        Expression spelExpression = spelParser.parseExpression(userInput);
        // 安全上下文：仅允许读写数据绑定，禁止类型访问和方法调用
        SimpleEvaluationContext safeContext = SimpleEvaluationContext.forReadWriteDataBinding().build();
        // 在限制上下文执行表达式（恶意代码会被拦截）
        Object result = spelExpression.getValue(safeContext);
        return "{\"status\":\"安全执行完成（限制上下文）\", \"result\":\"" + result + "\"}";
    }

    /**
     * 安全示例2：对用户输入实施白名单验证
     * 安全措施：
     * 1. 仅允许预定义的安全表达式通过验证
     * 2. 拒绝所有未在白名单中的输入，彻底阻断恶意表达式
     */
    @GetMapping("/safe/whitelist-validation")
    public String safeSpelWhitelistValidation(@RequestParam String userInput) {
        // 严格验证：仅允许白名单中的表达式
        if (!isExpressionAllowed(userInput)) {
            return "{\"status\":\"输入验证失败（非白名单表达式）\"}";
        }
        // 使用限制上下文进一步增强安全
        SimpleEvaluationContext safeContext = SimpleEvaluationContext.forReadOnlyDataBinding().build();
        Expression spelExpression = spelParser.parseExpression(userInput);
        String result = spelExpression.getValue(safeContext).toString();
        return "{\"status\":\"安全执行完成（白名单验证）\", \"result\":\"" + result + "\"}";
    }

    /**
     * 安全示例3：使用参数化表达式传递用户输入
     * 安全措施：
     * 1. 表达式固定，用户输入仅作为变量值传递
     * 2. 避免用户输入直接参与表达式构造
     */
    @GetMapping("/safe/parameterized-expression")
    public String safeSpelParameterizedExpression(@RequestParam String userInput) {
        StandardEvaluationContext context = new StandardEvaluationContext();
        // 将用户输入作为变量传入（而非拼接进表达式）
        context.setVariable("safeParam", userInput);
        // 表达式固定，仅引用变量（无注入风险）
        Expression spelExpression = spelParser.parseExpression("#safeParam?.toString()");
        String result = spelExpression.getValue(context).toString();
        return "{\"status\":\"安全执行完成（参数化表达式）\", \"result\":\"" + result + "\"}";
    }

    /**
     * 表达式白名单验证（安全辅助方法）
     * 说明：仅允许完全可控的安全表达式，严格限制输入范围
     */
    private boolean isExpressionAllowed(String input) {
        // 白名单仅包含安全的常量表达式（根据业务需求扩展）
        String[] allowedExpressions = {"true", "false", "null", "1+1", "3*4"};
        for (String allowed : allowedExpressions) {
            if (allowed.equals(input)) {
                return true;
            }
        }
        return false;
    }
}
    