package com.freedom.securitysamples.api.groovyInjection;

import groovy.lang.Binding;
import groovy.lang.GroovyClassLoader;
import groovy.lang.GroovyCodeSource;
import groovy.lang.GroovyObject;
import groovy.lang.GroovyShell;
import groovy.lang.Script;
import groovy.util.Eval;
import groovy.util.GroovyScriptEngine;
import org.codehaus.groovy.control.CompilerConfiguration;
import org.springframework.scripting.ScriptSource;
import org.springframework.scripting.groovy.GroovyScriptEvaluator;
import org.springframework.scripting.support.StaticScriptSource;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import javax.script.ScriptEngine;
import javax.script.ScriptEngineManager;
import java.io.File;
import java.io.StringReader;

/**
 * Groovy代码注入漏洞示例控制器
 * 说明：Groovy注入是一种代码注入漏洞，攻击者通过注入恶意Groovy代码片段，
 *       在服务器上执行未授权的操作。由于Groovy是一种运行在JVM上的动态语言，
 *       具有强大的反射和元编程能力，成功的注入可能导致严重的安全后果。
 * 常见风险：
 * 1. 远程代码执行（如执行系统命令、删除文件等）
 * 2. 服务器信息泄露（如系统配置、敏感文件内容）
 * 3. 权限提升和完全控制系统
 * 4. 数据泄露或破坏
 * 修复原则：
 * 1. 避免执行任何来自不可信来源的脚本代码
 * 2. 如必须使用，实施严格的输入验证和白名单机制
 * 3. 使用最小权限原则配置执行环境
 * 4. 限制脚本可访问的类和方法
 * 5. 考虑使用沙箱环境隔离脚本执行
 */
@RestController
@RequestMapping("/security-example/groovy-injection")
public class GroovyInjectionVulnerabilityController {

    /**
     * 不安全示例：使用GroovyScriptEvaluator执行用户输入的脚本
     * 漏洞点：直接将用户输入作为Groovy脚本执行
     * 风险：攻击者可注入任意Groovy代码，如执行系统命令
     * 示例攻击输入："println 'Hello from injection'; java.lang.Runtime.getRuntime().exec('ls')"
     */
    @GetMapping("/unsafe/evaluator")
    public String unsafeScriptWithEvaluator(@RequestParam String groovyScript) {
        // 危险实践：直接执行用户提供的Groovy脚本
        GroovyScriptEvaluator scriptEvaluator = new GroovyScriptEvaluator();
        ScriptSource scriptSource = new StaticScriptSource(groovyScript);
        scriptEvaluator.evaluate(scriptSource);
        return "{\"message\":\"脚本执行完成（不安全方式）\"}";
    }

    /**
     * 不安全示例：使用GroovyClassLoader加载并执行用户输入的脚本
     * 漏洞点：将用户输入解析为Groovy类并实例化执行
     * 风险：攻击者可注入完整的恶意类定义，执行危险操作
     * 示例攻击输入："class Evil { Evil() { java.lang.Runtime.getRuntime().exec('rm -rf /tmp/test') } }"
     */
    @GetMapping("/unsafe/class-loader")
    public String unsafeScriptWithClassLoader(@RequestParam String groovyScript) 
            throws InstantiationException, IllegalAccessException {
        // 危险实践：将用户输入解析为类并实例化，构造函数中的代码会被执行
        final GroovyClassLoader groovyClassLoader = new GroovyClassLoader();
        Class<?> parsedClass = groovyClassLoader.parseClass(groovyScript);
        GroovyObject groovyObject = (GroovyObject) parsedClass.newInstance();
        return "{\"message\":\"类加载执行完成（不安全方式）\"}";
    }

    /**
     * 不安全示例：使用Eval.me执行用户输入的脚本
     * 漏洞点：使用Groovy的Eval工具直接执行用户输入
     * 风险：简洁的接口使攻击者能轻松注入恶意代码
     * 示例攻击输入："java.lang.System.exit(0)"
     */
    @GetMapping("/unsafe/eval")
    public String unsafeScriptWithEval(@RequestParam String groovyScript){
        // 危险实践：使用Eval直接执行用户输入的脚本
        Eval.me(groovyScript);
        return "{\"message\":\"Eval执行完成（不安全方式）\"}";
    }

    /**
     * 不安全示例：使用GroovyShell执行用户输入的脚本
     * 漏洞点：通过GroovyShell直接评估用户提供的脚本
     * 风险：攻击者可利用GroovyShell的强大功能执行系统命令
     * 示例攻击输入："new File('/etc/passwd').text"
     */
    @GetMapping("/unsafe/shell")
    public String unsafeScriptWithShell(@RequestParam String groovyScript){
        // 危险实践：使用GroovyShell执行用户输入的脚本
        GroovyShell groovyShell = new GroovyShell();
        groovyShell.evaluate(groovyScript);
        return "{\"message\":\"GroovyShell执行完成（不安全方式）\"}";
    }

    /**
     * 不安全示例：使用GroovyCodeSource执行用户输入的脚本
     * 漏洞点：将用户输入包装为GroovyCodeSource并执行
     * 风险：即使使用CodeSource，未经处理的用户输入仍然危险
     * 示例攻击输入："println 'Injected code'; new File('secret.txt').delete()"
     */
    @GetMapping("/unsafe/code-source")
    public String unsafeScriptWithCodeSource(@RequestParam String groovyScript){
        // 危险实践：将用户输入包装为GroovyCodeSource执行
        GroovyShell groovyShell = new GroovyShell();
        GroovyCodeSource codeSource = new GroovyCodeSource(groovyScript, "injectedScript", "unsafe");
        groovyShell.evaluate(codeSource);
        return "{\"message\":\"CodeSource执行完成（不安全方式）\"}";
    }

    /**
     * 不安全示例：使用Binding传递变量执行包含用户输入的脚本
     * 漏洞点：即使通过Binding传递变量，仍可能在脚本中执行恶意代码
     * 风险：攻击者可注入闭合变量并添加新的恶意代码
     * 示例攻击输入："'; java.lang.Runtime.getRuntime().exec('id'); '"
     */
    @GetMapping("/unsafe/binding")
    public String unsafeScriptWithBinding(@RequestParam String userInput) {
        // 危险实践：将用户输入作为变量传入，但脚本中仍可能被注入
        Binding binding = new Binding();
        binding.setVariable("input", userInput);
        GroovyShell shell = new GroovyShell(binding);
        // 看似安全的打印操作，但用户输入可能包含闭合引号和恶意代码
        shell.evaluate("println input");
        return "{\"message\":\"Binding变量执行完成（不安全方式）\"}";
    }

    /**
     * 不安全示例：使用javax.script.ScriptEngine执行Groovy脚本
     * 漏洞点：通过标准脚本引擎接口执行用户提供的Groovy代码
     * 风险：与其他方法一样，可导致远程代码执行
     * 示例攻击输入："println 'ScriptEngine injection'; java.io.File.listRoots().each { println it }"
     */
    @GetMapping("/unsafe/script-engine")
    public String unsafeScriptWithScriptEngine(@RequestParam String groovyScript) throws Exception {
        // 危险实践：通过标准脚本引擎执行用户提供的Groovy代码
        ScriptEngineManager factory = new ScriptEngineManager();
        ScriptEngine engine = factory.getEngineByName("groovy");
        engine.eval(new StringReader(groovyScript));
        return "{\"message\":\"ScriptEngine执行完成（不安全方式）\"}";
    }

    /**
     * 不安全示例：使用自定义编译配置执行用户输入的脚本
     * 漏洞点：即使有自定义配置，直接执行用户输入仍不安全
     * 风险：攻击者可绕过简单配置执行恶意代码
     * 示例攻击输入："this.class.classLoader.rootLoader.loadClass('java.lang.Runtime').getRuntime().exec('whoami')"
     */
    @GetMapping("/unsafe/custom-config")
    public String unsafeScriptWithCustomConfig(@RequestParam String groovyScript) {
        // 危险实践：自定义配置但仍执行未验证的用户输入
        CompilerConfiguration config = new CompilerConfiguration();
        GroovyShell shell = new GroovyShell(config);
        shell.evaluate(groovyScript);
        return "{\"message\":\"自定义配置执行完成（不安全方式）\"}";
    }

    /**
     * 不安全示例：从用户指定的文件加载并执行Groovy脚本
     * 漏洞点：允许用户控制脚本文件路径，可能执行系统中任意脚本
     * 风险：攻击者可指定包含恶意代码的脚本文件路径
     * 示例攻击输入："/tmp/evil-script.groovy"
     */
    @GetMapping("/unsafe/file-execution")
    public String unsafeScriptFromFile(@RequestParam String filePath) throws Exception {
        // 危险实践：执行用户指定路径的脚本文件
        GroovyScriptEngine engine = new GroovyScriptEngine(new String[]{filePath});
        engine.run(new File(filePath).getName(), "");
        return "{\"message\":\"文件脚本执行完成（不安全方式）\"}";
    }

    /**
     * 不安全示例：使用BaseScript配置执行用户输入的脚本
     * 漏洞点：即使指定基础脚本类，仍直接执行用户输入
     * 风险：攻击者可利用基础脚本类的功能实施攻击
     * 示例攻击输入："println 'BaseScript injection'; System.getenv().each { println it }"
     */
    @GetMapping("/unsafe/base-script")
    public String unsafeScriptWithBaseScript(@RequestParam String groovyScript) {
        // 危险实践：配置基础脚本类但仍执行未验证的用户输入
        CompilerConfiguration config = new CompilerConfiguration();
        config.setScriptBaseClass("groovy.lang.Script");
        GroovyShell shell = new GroovyShell(config);
        shell.evaluate(groovyScript);
        return "{\"message\":\"BaseScript执行完成（不安全方式）\"}";
    }
}