package com.freedom.securitysamples.api.thirdParty;

import com.thoughtworks.xstream.XStream;
import com.thoughtworks.xstream.io.xml.DomDriver;
import org.springframework.web.bind.annotation.*;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

/**
 * XStream反序列化漏洞示例控制器
 * 说明：XStream是一个Java对象与XML相互转换的库，若配置不当，攻击者可通过构造恶意XML数据，
 *       在反序列化过程中执行任意代码，导致远程代码执行(RCE)等严重安全事件。
 * 常见风险：
 * 1. 远程代码执行：攻击者可执行系统命令（如删除文件、植入后门）
 * 2. 服务器信息泄露：获取系统配置、敏感文件内容
 * 3. 权限提升：通过执行特权操作获取更高系统权限
 * 修复原则：
 * 1. 限制允许反序列化的类：使用allowTypes()或allowTypesByRegExp()明确指定安全类
 * 2. 升级XStream版本：使用修复了已知漏洞的最新版本
 * 3. 避免反序列化不受信任的数据：对输入XML进行严格验证
 * 4. 禁用危险功能：如外部实体解析、远程类加载等
 * 5. 使用替代方案：考虑更安全的序列化方式（如JSON库配合严格的类型检查）
 */
@RestController
@RequestMapping("/security-example/xstream")
public class XstreamDeserializationVulnerabilityController {

    /**
     * 不安全示例1：使用XStream默认配置反序列化
     * 漏洞点：
     * 1. 未进行任何安全配置，使用XStream默认构造函数
     * 2. 直接对用户输入的XML数据进行反序列化
     * 风险：攻击者可构造包含恶意类的XML，触发远程代码执行
     * 攻击示例：构造包含java.lang.Runtime的XML，执行系统命令
     */
    @PostMapping("/unsafe/default-config")
    public String unsafeDeserializationWithDefaultConfig(@RequestBody String xmlData) {
        XStream xstream = new XStream();
        // 危险实践：默认配置允许反序列化所有类，无任何安全限制
        Object obj = xstream.fromXML(xmlData);
        return "处理完成：" + obj.toString();
    }

    /**
     * 不安全示例2：过度宽松的类型允许策略
     * 漏洞点：
     * 1. 调用allowTypes()允许Object.class（所有类的父类）
     * 2. 实质上等于允许所有类进行反序列化
     * 风险：攻击者可注入任意类的实例，执行恶意逻辑
     * 原理：Object是所有类的超类，允许它等于取消所有类型限制
     */
    @PostMapping("/unsafe/allow-all-types")
    public String unsafeDeserializationWithOverlyPermissiveTypes(@RequestBody String xmlData) {
        XStream xstream = new XStream(new DomDriver());
        // 危险实践：允许Object类会导致所有类都能被反序列化
        xstream.allowTypes(new Class[]{Object.class});
        return "结果：" + xstream.fromXML(xmlData);
    }

    /**
     * 不安全示例3：过于宽松的通配符类型匹配
     * 漏洞点：
     * 1. 使用allowTypesByWildcard()配置过于宽泛的包匹配（com.freedom.**）
     * 2. 可能包含应用中未预期的危险类
     * 风险：攻击者可利用目标包中存在的危险类构造攻击 payload
     * 示例：若com.freedom包下有文件操作相关类，可能被用于读取敏感文件
     */
    @PostMapping("/unsafe/wildcard-types")
    public String unsafeDeserializationWithBroadWildcard(@RequestBody String xmlData) {
        XStream xstream = new XStream();
        // 危险实践：通配符过于宽松，可能包含危险类
        xstream.allowTypesByWildcard(new String[]{"com.freedom.**"});
        return "处理结果：" + xstream.fromXML(xmlData);
    }

    /**
     * 不安全示例4：文件操作与反序列化结合
     * 漏洞点：
     * 1. 将不受信任的XML数据写入文件后再反序列化
     * 2. 未验证文件内容安全性，直接进行反序列化处理
     * 风险：攻击者可通过恶意XML操控文件系统，甚至执行命令
     * 扩展风险：临时文件可能被其他进程访问，扩大攻击面
     */
    @PostMapping("/unsafe/file-based")
    public String unsafeFileBasedDeserialization(@RequestBody String xmlData) {
        try {
            XStream xstream = new XStream();
            // 危险实践1：将不受信任数据写入文件
            File tempFile = new File("temp.xml");
            FileOutputStream fos = new FileOutputStream(tempFile);
            fos.write(xmlData.getBytes());
            fos.close();

            // 危险实践2：从不可信文件中读取并反序列化
            FileInputStream fis = new FileInputStream(tempFile);
            Object obj = xstream.fromXML(fis);
            fis.close();
            return "文件处理完成：" + obj.toString();
        } catch (IOException e) {
            return "错误：" + e.getMessage();
        }
    }

    /**
     * 不安全示例5：不安全的自定义转换器
     * 漏洞点：
     * 1. 注册的自定义转换器未进行类型安全检查
     * 2. 转换器接受所有类型并直接进行反序列化
     * 风险：绕过XStream的默认安全机制，允许恶意类实例化
     * 原理：自定义转换器若实现不当，会成为新的安全漏洞入口
     */
    @PostMapping("/unsafe/custom-converter")
    public String unsafeDeserializationWithCustomConverter(@RequestBody String xmlData) {
        XStream xstream = new XStream();
        // 危险实践：注册不安全的自定义转换器
        xstream.registerConverter(new UnsafeCustomConverter());
        return "转换结果：" + xstream.fromXML(xmlData);
    }

    /**
     * 不安全示例6：允许远程资源加载
     * 漏洞点：
     * 1. 明确允许java.net.URL等远程资源类进行反序列化
     * 2. 可能导致服务器加载外部恶意资源
     * 风险：攻击者可诱导服务器访问恶意URL，泄露信息或执行远程代码
     * 扩展风险：结合其他漏洞可构成完整攻击链（如SSRF+反序列化）
     */
    @PostMapping("/unsafe/remote-loading")
    public String unsafeDeserializationWithRemoteLoading(@RequestBody String xmlData) {
        XStream xstream = new XStream();
        // 危险实践：允许URL等远程资源类，可能导致远程资源加载
        xstream.allowTypes(new Class[]{java.net.URL.class});
        return "远程加载结果：" + xstream.fromXML(xmlData);
    }
}

/**
 * 不安全的自定义转换器示例
 * 漏洞说明：
 * 1. canConvert()方法返回true，接受所有类型的转换请求
 * 2. unmarshal()方法未进行任何安全验证，直接转换所有输入
 * 3. 完全绕过XStream的类型安全检查机制
 */
class UnsafeCustomConverter implements com.thoughtworks.xstream.converters.Converter {
    @Override
    public boolean canConvert(Class type) {
        // 危险：接受所有类的转换请求
        return true;
    }

    @Override
    public void marshal(Object source, com.thoughtworks.xstream.io.HierarchicalStreamWriter writer,
                        com.thoughtworks.xstream.converters.MarshallingContext context) {
        // 序列化逻辑（本示例未实现）
    }

    @Override
    public Object unmarshal(com.thoughtworks.xstream.io.HierarchicalStreamReader reader,
                            com.thoughtworks.xstream.converters.UnmarshallingContext context) {
        // 危险：未进行任何安全检查，直接反序列化所有类型
        return context.convertAnother(reader, Object.class);
    }
}
