package com.freedom.securitysamples.api.thirdParty;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONObject;
import com.alibaba.fastjson.parser.Feature;
import com.alibaba.fastjson.parser.ParserConfig;
import org.springframework.web.bind.annotation.*;

import java.util.Map;

/**
 * Fastjson反序列化漏洞示例控制器
 * 说明：Fastjson反序列化漏洞是指攻击者通过构造恶意JSON数据，利用Fastjson的配置缺陷（如开启AutoType、使用泛型/Object作为目标类型），
 *       触发恶意类的实例化与方法执行，可能导致远程代码执行（RCE）、服务器权限被窃取等严重后果。
 * 常见风险原因：
 * 1. 开启全局AutoType支持（setAutoTypeSupport(true)），允许反序列化任意类
 * 2. 使用Object/泛型作为反序列化目标类型，无法限制恶意类
 * 3. 启用危险解析特征（如SupportNonPublicField），可篡改私有字段触发漏洞
 * 4. 未配置类白名单，无法过滤恶意类（如TemplatesImpl、JdbcRowSetImpl）
 * 修复原则：
 * 1. 禁用全局AutoType支持（默认禁用，避免主动开启）
 * 2. 使用局部ParserConfig（而非全局），避免影响全局配置
 * 3. 指定具体的反序列化目标类型（如自定义DTO），拒绝Object/泛型
 * 4. 配置类白名单（addAccept），仅允许信任的类进行反序列化
 * 5. 禁用危险解析特征，避免私有字段篡改
 * 6. 对反序列化结果进行输入验证，过滤恶意数据
 */
@RestController
@RequestMapping("/security-example/fastjson")
public class FastjsonDeserializationVulnerabilityController {

    /**
     * 不安全示例1：未指定目标类型且依赖默认AutoType配置
     * 漏洞点：
     * 1. 未明确反序列化目标类型（默认反序列化为JSONObject，但若全局AutoType开启则风险扩散）
     * 2. 使用不可信的JSON输入（untrustedJsonStr），未做任何安全限制
     * 风险：若全局AutoType被其他代码开启，攻击者可构造恶意JSON（如注入TemplatesImpl类），触发远程代码执行
     * 示例攻击JSON：{"@type":"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl","_bytecodes":["yv66vgAA..."],"_name":"a","_tfactory":{}}
     */
    @PostMapping("/unsafe/parse-object-with-default-config")
    public String unsafeParseObjectWithDefaultConfig(@RequestBody String untrustedJsonStr) {
        // 危险实践：使用JSON.parseObject处理不可信JSON，未指定具体目标类型，依赖默认配置
        Object deserializedObj = JSON.parseObject(untrustedJsonStr);
        return "不安全处理结果：" + deserializedObj.toString();
    }

    /**
     * 不安全示例2：全局开启AutoType支持（高危）
     * 漏洞点：
     * 1. 全局开启ParserConfig的AutoType支持（setAutoTypeSupport(true)），影响所有Fastjson解析逻辑
     * 2. 未配置类白名单，允许反序列化任意类
     * 风险：攻击者可构造包含恶意类（如JdbcRowSetImpl、TemplatesImpl）的JSON，直接执行远程代码（如执行cmd命令）
     * 关键提醒：全局开启AutoType是Fastjson漏洞的核心诱因，生产环境绝对禁止！
     */
    @PostMapping("/unsafe/parse-with-global-autotype-enabled")
    public String unsafeParseWithGlobalAutoTypeEnabled(@RequestBody String untrustedJsonStr) {
        // 极度危险：全局开启AutoType，所有Fastjson解析都会受此影响，漏洞扩散至整个应用
        ParserConfig.getGlobalInstance().setAutoTypeSupport(true);
        // 无限制反序列化，恶意JSON可触发任意类实例化
        Object deserializedObj = JSON.parseObject(untrustedJsonStr);
        return "不安全处理结果（全局AutoType开启）：" + deserializedObj.toString();
    }

    /**
     * 不安全示例3：使用JSON.parse()处理不可信输入
     * 漏洞点：
     * 1. 使用JSON.parse()而非指定目标类型的parseObject，解析结果为Object类型，无法限制类范围
     * 2. 未禁用AutoType（若局部/全局AutoType开启则直接触发漏洞）
     * 风险：与示例2类似，恶意JSON可注入恶意类，触发反序列化RCE
     * 原理：JSON.parse()默认支持AutoType（若配置允许），且返回Object类型，无法过滤危险类
     */
    @PostMapping("/unsafe/parse-with-object-return")
    public String unsafeParseWithObjectReturn(@RequestBody String untrustedJsonStr) {
        // 危险实践：使用JSON.parse()处理不可信输入，返回Object类型，无类范围限制
        Object deserializedObj = JSON.parse(untrustedJsonStr);
        return "不安全处理结果（JSON.parse()）：" + deserializedObj.toString();
    }

    /**
     * 不安全示例4：启用危险解析特征（SupportNonPublicField）
     * 漏洞点：
     * 1. 启用Feature.SupportNonPublicField特征，允许Fastjson修改目标类的私有字段
     * 2. 未指定具体目标类型，且未限制AutoType
     * 风险：攻击者可通过修改恶意类的私有字段（如TemplatesImpl的_bytecodes），构造可执行代码的实例
     * 原理：SupportNonPublicField会绕过私有字段访问限制，使攻击者能注入恶意字节码或配置
     */
    @PostMapping("/unsafe/parse-with-dangerous-feature")
    public String unsafeParseWithDangerousFeature(@RequestBody String untrustedJsonStr) {
        // 危险实践：启用SupportNonPublicField特征，同时处理不可信JSON
        Object deserializedObj = JSON.parseObject(untrustedJsonStr, Feature.SupportNonPublicField);
        return "不安全处理结果（启用SupportNonPublicField）：" + deserializedObj.toString();
    }

    /**
     * 不安全示例5：泛型Map作为反序列化目标类型
     * 漏洞点：
     * 1. 使用Map<String, Object>作为反序列化目标，泛型中的Object允许嵌套恶意类
     * 2. 未禁用AutoType，恶意JSON可在Map值中注入危险类实例
     * 风险：攻击者可构造Map结构的JSON，在value中嵌入恶意类（如CommonsBeanutils的BeanComparator），触发漏洞
     * 示例攻击JSON：{"maliciousKey":{"@type":"org.apache.commons.beanutils.BeanComparator","property":"classLoader"}}
     */
    @PostMapping("/unsafe/parse-to-generic-map")
    public String unsafeParseToGenericMap(@RequestBody String untrustedJsonStr) {
        // 危险实践：使用泛型Map<Object>作为目标类型，允许嵌套恶意类
        Map<String, Object> untrustedMap = JSON.parseObject(untrustedJsonStr, Map.class);
        return "不安全处理结果（泛型Map）：" + untrustedMap.toString();
    }

    /**
     * 不安全示例6：TypeReference使用不当（实际传Object.class）
     * 漏洞点：
     * 1. 名义上想使用TypeReference限制类型，但实际传入Object.class，等同于无类型限制
     * 2. 未配置安全解析规则，无法抵御恶意JSON
     * 风险：与示例3一致，攻击者可构造恶意类JSON，触发反序列化漏洞
     * 关键提醒：TypeReference的正确用法是指定具体类（如new TypeReference<UserDTO>(){}），传Object.class无任何安全意义
     */
    @PostMapping("/unsafe/incorrect-type-reference")
    public String unsafeIncorrectTypeReference(@RequestBody String untrustedJsonStr) {
        // 错误实践：TypeReference传入Object.class，未起到任何类型限制作用
        Object deserializedObj = JSON.parseObject(untrustedJsonStr, Object.class);
        return "不安全处理结果（TypeReference误用）：" + deserializedObj.toString();
    }

    /**
     * 安全示例1：禁用AutoType + 指定具体JSON目标类型
     * 修复方式：
     * 1. 明确禁用全局AutoType（避免其他代码误开启）
     * 2. 指定反序列化目标为JSONObject（Fastjson内置安全类型，无实例化风险）
     * 原理：JSONObject是Fastjson原生数据结构，不会触发外部类实例化；禁用AutoType可彻底阻断恶意类注入
     */
    @PostMapping("/safe/parse-to-json-object")
    public String safeParseToJsonObject(@RequestBody String untrustedJsonStr) {
        // 安全实践1：禁用全局AutoType，避免AutoType漏洞
        ParserConfig.getGlobalInstance().setAutoTypeSupport(false);
        // 安全实践2：指定具体目标类型为JSONObject，拒绝Object/泛型
        JSONObject safeJsonObject = JSON.parseObject(untrustedJsonStr, JSONObject.class);
        return "安全处理结果（指定JSONObject）：" + safeJsonObject.toString();
    }

    /**
     * 安全示例2：局部ParserConfig + 类白名单 + 具体类型
     * 修复方式：
     * 1. 使用局部ParserConfig（而非全局），避免影响其他解析逻辑
     * 2. 开启安全模式（setSafeMode(true)），进一步限制危险类
     * 3. 配置类白名单（addAccept），仅允许信任的业务包下的类
     * 4. 指定目标类型为JSONObject，双重保障
     * 原理：局部配置隔离风险，白名单严格限制可反序列化的类，避免恶意类注入
     */
    @PostMapping("/safe/local-config-with-whitelist")
    public String safeLocalConfigWithWhitelist(@RequestBody String untrustedJsonStr) {
        try {
            // 安全实践1：使用局部ParserConfig，不影响全局配置
            ParserConfig safeLocalConfig = new ParserConfig();
            // 安全实践2：开启安全模式，禁用危险解析逻辑
            safeLocalConfig.setSafeMode(true);
            // 安全实践3：添加类白名单，仅允许业务包下的类（如用户DTO、订单DTO）
            safeLocalConfig.addAccept("com.freedom.securitysamples.model.");

            // 安全实践4：指定具体目标类型为JSONObject
            JSONObject safeResult = JSON.parseObject(untrustedJsonStr, JSONObject.class, safeLocalConfig);
            return "安全处理结果（局部配置+白名单）：" + safeResult.toString();
        } catch (Exception e) {
            // 安全实践5：捕获异常，拒绝恶意JSON处理
            return "安全拦截：非法JSON或未授权反序列化类型，错误信息：" + e.getMessage();
        }
    }

    /**
     * 安全示例3：自定义DTO + 输入验证
     * 修复方式：
     * 1. 禁用AutoType，阻断恶意类注入
     * 2. 指定反序列化目标为自定义UserDTO（业务相关具体类，无风险）
     * 3. 对DTO进行输入验证（validate方法），过滤非法数据（如无效邮箱、空用户名）
     * 原理：自定义DTO是业务可控的安全类，无恶意方法；输入验证可进一步抵御恶意数据（如超长字符串、特殊字符）
     */
    @PostMapping("/safe/parse-to-custom-dto")
    public String safeParseToCustomDto(@RequestBody String untrustedJsonStr) {
        try {
            // 安全实践1：确保AutoType禁用
            ParserConfig.getGlobalInstance().setAutoTypeSupport(false);

            // 安全实践2：指定具体目标类型为UserDTO（业务自定义安全类）
            UserDTO userDto = JSON.parseObject(untrustedJsonStr, UserDTO.class);

            // 安全实践3：对反序列化结果进行输入验证，排除非法数据
            if (userDto != null && userDto.validate()) {
                return "安全处理结果（自定义DTO）：有效的用户数据 = " + userDto.toString();
            } else {
                return "安全拦截：无效的用户数据（如空用户名、非法邮箱）";
            }
        } catch (Exception e) {
            return "安全拦截：反序列化失败，错误信息：" + e.getMessage();
        }
    }

    /**
     * 安全反序列化目标类：用户数据传输对象（DTO）
     * 作用：作为Fastjson反序列化的具体目标，避免使用Object/泛型导致的漏洞；
     *      包含输入验证逻辑，进一步保障数据合法性。
     * 设计原则：DTO仅包含业务必要字段（username/email），无复杂逻辑，避免成为攻击入口。
     */
    static class UserDTO {
        // 业务必要字段，无多余风险字段
        private String username;
        private String email;

        // Getter/Setter：仅暴露必要的字段访问接口
        public String getUsername() {
            return username;
        }

        public void setUsername(String username) {
            this.username = username;
        }

        public String getEmail() {
            return email;
        }

        public void setEmail(String email) {
            this.email = email;
        }

        /**
         * 输入验证方法：过滤非法数据
         * 验证逻辑：
         * 1. 用户名非空
         * 2. 邮箱符合标准格式（避免注入特殊字符）
         * 作用：即使反序列化成功，也能通过验证阻断恶意数据进入业务逻辑
         */
        public boolean validate() {
            // 用户名非空校验
            boolean isUsernameValid = username != null && !username.trim().isEmpty();
            // 邮箱格式正则校验（简单版，生产环境可使用更严谨的正则）
            boolean isEmailValid = email != null && email.matches("^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+$");
            return isUsernameValid && isEmailValid;
        }

        @Override
        public String toString() {
            return "UserDTO{" +
                    "username='" + username + '\'' +
                    ", email='" + email + '\'' +
                    '}';
        }
    }
}