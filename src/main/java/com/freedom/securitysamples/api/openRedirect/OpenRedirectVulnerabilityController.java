package com.freedom.securitysamples.api.openRedirect;

import jakarta.servlet.http.HttpServletResponse;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.view.RedirectView;

import java.io.IOException;

/**
 * 开放重定向漏洞示例控制器
 * 说明：开放重定向（Open Redirect）是指应用程序未验证用户提供的重定向URL，直接用于跳转
 * 安全风险：攻击者可构造恶意链接，诱导用户跳转至钓鱼网站、恶意页面，导致信息泄露或诈骗
 * 修复建议：1. 使用白名单限制允许重定向的域名 2. 禁止使用用户输入直接拼接URL 3. 采用相对路径而非绝对路径 4. 对用户输入进行严格校验和过滤
 */
@Controller
@RequestMapping("/security-example/open-redirect")
public class OpenRedirectVulnerabilityController {

    /**
     * 不安全示例1：直接拼接用户提供的URL进行重定向
     * 漏洞点：未验证用户输入的URL，直接作为重定向目标
     * 攻击示例：访问 /security-example/open-redirect/unsafe/direct-redirect?userProvidedUrl=https://malicious.com 会跳转到恶意网站
     */
    @GetMapping("/unsafe/direct-redirect")
    public String unsafeDirectUrlRedirect(@RequestParam String userProvidedUrl) {
        // 危险操作：直接使用用户输入的URL进行重定向，无任何验证
        return "redirect:" + userProvidedUrl;
    }

    /**
     * 不安全示例2：使用ModelAndView重定向但未验证URL
     * 漏洞点：通过ModelAndView设置重定向视图时，直接使用用户提供的URL
     * 风险场景：攻击者可伪造"登录后跳转"链接，诱导用户在登录后跳转到恶意网站
     */
    @GetMapping("/unsafe/model-and-view-redirect")
    public ModelAndView unsafeModelAndViewRedirect(@RequestParam String userProvidedUrl) {
        ModelAndView modelAndView = new ModelAndView();
        // 危险操作：将用户输入直接作为重定向目标视图
        modelAndView.setViewName("redirect:" + userProvidedUrl);
        return modelAndView;
    }

    /**
     * 不安全示例3：使用RedirectView重定向但未验证URL
     * 漏洞点：RedirectView直接接收用户提供的URL作为跳转目标
     * 攻击特点：即使设置contextRelative=true，仍可被绝对路径URL（如https://evil.com）绕过
     */
    @GetMapping("/unsafe/redirect-view-redirect")
    public RedirectView unsafeRedirectViewRedirect(@RequestParam String userProvidedUrl) {
        // 危险操作：直接使用用户输入创建RedirectView
        return new RedirectView(userProvidedUrl);
    }

    /**
     * 不安全示例4：使用forward转发未验证的路径
     * 漏洞点：用户可控的路径被用于服务器内部转发，可能导致敏感资源访问
     * 攻击示例：传入 ../../admin/dashboard 可能绕过权限控制访问管理页面
     */
    @GetMapping("/unsafe/forward-request")
    public String unsafeForwardRequest(@RequestParam String userProvidedPath) {
        // 危险操作：直接转发到用户提供的路径，存在路径遍历风险
        return "forward:" + userProvidedPath;
    }

    /**
     * 不安全示例5：通过HttpServletResponse重定向未验证的URL
     * 漏洞点：直接调用sendRedirect()使用用户提供的URL
     * 常见场景："登录成功后跳转"功能中，若redirectUrl参数未验证则存在此风险
     */
    @GetMapping("/unsafe/response-redirect")
    public void unsafeResponseRedirect(HttpServletResponse response, @RequestParam String userProvidedUrl)
            throws IOException {
        // 危险操作：直接将用户输入传给sendRedirect()
        response.sendRedirect(userProvidedUrl);
    }

    /**
     * 不安全示例6：简单校验易被绕过
     * 漏洞点：仅校验URL是否以http://或https://开头，无法阻止恶意域名
     * 绕过示例：用户输入 http://example.com.evil.com（看似合法域名的子域，实际为恶意域名）
     * 绕过示例2：http://evil.com?example.com（通过参数伪装合法域名）
     */
    @GetMapping("/unsafe/simple-validation-bypass")
    public String unsafeSimpleValidation(@RequestParam String userProvidedUrl) {
        // 无效校验：仅检查协议头，无法阻止恶意域名
        if (userProvidedUrl.startsWith("http://") || userProvidedUrl.startsWith("https://")) {
            return "redirect:" + userProvidedUrl;
        }
        return "redirect:/home";
    }

    /**
     * 不安全示例7：URL拼接未验证路径
     * 漏洞点：用户提供的路径片段直接拼接到基础URL，可能导致路径跳转
     * 攻击示例：path传入 ../../evil.com 会拼接为 https://example.com/../../evil.com，实际跳转到evil.com
     */
    @GetMapping("/unsafe/url-join-unsafe")
    public String unsafeUrlJoin(@RequestParam String userProvidedPath) {
        // 危险拼接：用户输入直接拼接到基础URL，存在路径遍历风险
        return "redirect:https://example.com/" + userProvidedPath;
    }

    /**
     * 不安全示例8：多参数拼接未验证
     * 漏洞点：用户提供的域名和路径拼接后直接作为重定向目标
     * 攻击示例：domain传入 http://evil.com，path传入任意值，最终跳转到恶意域名
     */
    @GetMapping("/unsafe/multi-params-join")
    public String unsafeMultiParamsJoin(
            @RequestParam String userProvidedDomain,
            @RequestParam String userProvidedPath) {
        // 危险操作：多个用户输入直接拼接为URL，完全可控
        return "redirect:" + userProvidedDomain + "/" + userProvidedPath;
    }
}
    