package com.freedom.securitysamples.api.defaultCredentials;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

/**
 * 默认凭证漏洞示例控制器
 * 说明：默认凭证漏洞指系统中存在预设的、未修改的默认用户名和密码，
 *       攻击者可利用这些广为人知的默认凭证非法访问系统。
 * 常见风险：
 * 1. 攻击者无需授权即可登录系统，获取敏感信息
 * 2. 可能导致系统被恶意操控、数据篡改或破坏
 * 3. 影响范围广泛，从后台管理系统到物联网设备均可能存在
 * 修复原则：
 * 1. 禁止在代码中硬编码任何凭证信息
 * 2. 强制要求用户首次登录时修改默认密码
 * 3. 默认凭证应具有足够复杂度，且不对外公开
 * 4. 使用安全的认证框架（如Spring Security）管理凭证
 * 5. 凭证需加密存储，避免明文形式出现
 */
@RestController
@RequestMapping("/security-example/default-credentials")
public class DefaultCredentialsVulnerabilityController {

    /**
     * 不安全示例：硬编码的默认凭证
     * 漏洞点：
     * 1. 用户名和密码直接写在代码中（硬编码），容易被反编译获取
     * 2. 凭证复杂度极低（123456），极易被猜测
     * 3. 未提供强制修改默认凭证的机制
     * 4. 所有部署实例使用相同的默认凭证，一旦泄露全部受影响
     */
    private static final String HARDCODED_USERNAME = "admin";  // 危险：硬编码的默认用户名
    private static final String HARDCODED_PASSWORD = "123456"; // 危险：简单的默认密码


    /**
     * 不安全的登录接口（使用硬编码默认凭证）
     * 漏洞演示：任何人都可以使用admin/123456登录系统
     */
    @GetMapping("/unsafe/login")
    public String unsafeLogin(
            @RequestParam String username,
            @RequestParam String password) {
        // 危险实践：直接使用硬编码凭证进行身份验证
        if (HARDCODED_USERNAME.equals(username) && HARDCODED_PASSWORD.equals(password)) {
            return "{\"status\":\"success\",\"msg\":\"危险：使用默认硬编码凭证登录成功\"}";
        }
        return "{\"status\":\"failed\",\"msg\":\"登录失败\"}";
    }


    /**
     * 安全示例：改进的凭证管理方式
     * 修复说明：
     * 1. 从配置文件读取凭证（避免硬编码）
     * 2. 实际项目中应使用Spring Security等框架
     * 3. 密码应存储加密后的哈希值（而非明文）
     * 4. 应添加首次登录强制修改密码的逻辑
     */
    @Value("${app.credentials.username:notset}")  // 从配置文件读取
    private String configUsername;
    
    @Value("${app.credentials.password:notset}")  // 从配置文件读取（实际应存储哈希值）
    private String configPassword;

    /**
     * 相对安全的登录接口示例
     * 注意：这只是基础改进，生产环境需使用完整的认证框架
     */
    @GetMapping("/safe/login")
    public String safeLogin(
            @RequestParam String username,
            @RequestParam String password) {
        // 安全实践：从配置文件获取凭证（实际项目应使用密码哈希比对）
        if (configUsername.equals(username) && verifyPassword(password, configPassword)) {
            // 实际项目中应检查是否为首次登录，强制修改默认密码
            return "{\"status\":\"success\",\"msg\":\"登录成功（使用安全凭证管理方式）\"}";
        }
        return "{\"status\":\"failed\",\"msg\":\"登录失败\"}";
    }

    /**
     * 密码验证方法（示例）
     * 实际应使用BCrypt等算法验证哈希值，而非明文比对
     */
    private boolean verifyPassword(String inputPassword, String storedPassword) {
        // 生产环境示例：return BCrypt.checkpw(inputPassword, storedPassword);
        return inputPassword.equals(storedPassword); // 仅为演示，实际需使用哈希验证
    }
}
