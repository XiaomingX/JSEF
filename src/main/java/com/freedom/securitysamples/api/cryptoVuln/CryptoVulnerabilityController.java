package com.freedom.securitysamples.api.cryptoVuln;

import org.springframework.web.bind.annotation.*;
import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import java.security.MessageDigest;
import java.security.SecureRandom;
import java.util.Base64;

/**
 * 密码学安全漏洞示例控制器
 * 说明：密码学漏洞是指在加密、解密、哈希、密钥管理等密码学操作中存在的不安全实现，
 *       可能导致敏感信息被未授权访问、篡改或泄露。
 * 常见风险：
 * 1. 加密数据被破解（如使用弱算法或短密钥）
 * 2. 敏感信息泄露（如硬编码密钥被窃取）
 * 3. 数据完整性被破坏（如缺少校验机制）
 * 4. 身份认证被绕过（如不安全的随机数生成）
 * 修复原则：
 * 1. 使用经过验证的现代加密算法（如AES-256、SHA-256、RSA-2048+）
 * 2. 正确管理密钥（使用密钥管理系统，避免硬编码）
 * 3. 采用安全的加密模式（如CBC、GCM，避免ECB）
 * 4. 确保随机数生成器的安全性
 * 5. 对敏感操作添加完整性校验
 */
@RestController
@RequestMapping("/security-example/crypto-vulnerabilities")
public class CryptoVulnerabilityController {

    /**
     * 不安全示例：使用已被破解的弱加密算法
     * 漏洞点：
     * 1. 使用DES算法（数据加密标准），密钥长度仅56位
     * 2. DES在1999年已被证明可在短时间内被暴力破解
     * 风险：加密数据可被轻易破解，敏感信息泄露
     * 修复方案：
     * 1. 改用AES算法（高级加密标准）
     * 2. 密钥长度至少使用128位，推荐256位
     */
    @GetMapping("/unsafe/weak-encryption-algorithm")
    public String unsafeUseWeakEncryptionAlgorithm() throws Exception {
        String sensitiveData = "用户敏感信息";
        // 危险实践：使用DES算法（已被破解的弱加密算法）
        Cipher weakCipher = Cipher.getInstance("DES"); 
        return "已使用不安全的DES加密算法处理数据: " + sensitiveData;
    }

    /**
     * 不安全示例：使用固定初始化向量(IV)
     * 漏洞点：
     * 1. 使用固定不变的IV值，而非随机生成
     * 2. 在CBC等模式中，相同密钥+相同IV加密相同明文会产生相同密文
     * 风险：攻击者可通过分析密文模式推断明文内容，甚至实施选择明文攻击
     * 修复方案：
     * 1. 每次加密生成随机IV（长度与块大小一致，AES为16字节）
     * 2. IV无需保密，但需与密文一同传输/存储
     */
    @GetMapping("/unsafe/static-iv")
    public String unsafeUseStaticInitializationVector() throws Exception {
        // 危险实践：使用固定IV（全零向量）
        byte[] fixedInitializationVector = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                                           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
        IvParameterSpec staticIv = new IvParameterSpec(fixedInitializationVector);
        Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
        return "已使用固定不变的初始化向量(IV)进行加密";
    }

    /**
     * 不安全示例：使用弱哈希算法
     * 漏洞点：
     * 1. 使用MD5哈希算法，已被证明存在严重安全缺陷
     * 2. MD5抗碰撞性被攻破，可人为构造相同哈希值的不同数据
     * 风险：密码哈希可被彩虹表破解，数据完整性校验失效
     * 修复方案：
     * 1. 改用SHA-256及以上强度的哈希算法
     * 2. 存储密码时使用专门的密码哈希函数（如BCrypt、Argon2、PBKDF2）
     */
    @GetMapping("/unsafe/weak-hash-algorithm")
    public String unsafeUseWeakHashAlgorithm() throws Exception {
        String userPassword = "user123456";
        // 危险实践：使用MD5进行密码哈希
        MessageDigest weakDigest = MessageDigest.getInstance("MD5");
        byte[] hashedPassword = weakDigest.digest(userPassword.getBytes());
        return "已使用不安全的MD5算法哈希密码: " + Base64.getEncoder().encodeToString(hashedPassword);
    }

    /**
     * 不安全示例：硬编码密钥
     * 漏洞点：
     * 1. 密钥直接嵌入代码中，随代码一同发布
     * 2. 密钥无法安全更新，一旦代码泄露则密钥泄露
     * 风险：攻击者可通过反编译获取密钥，解密所有加密数据
     * 修复方案：
     * 1. 使用密钥管理系统(KMS)存储和获取密钥
     * 2. 采用环境变量或安全配置服务注入密钥
     * 3. 定期轮换密钥，且轮换过程安全可控
     */
    @GetMapping("/unsafe/hardcoded-key")
    public String unsafeUseHardcodedKey() {
        // 危险实践：密钥直接硬编码在代码中
        String hardcodedEncryptionKey = "1234567890abcdef"; // 实际开发中这是致命错误
        return "已使用硬编码的加密密钥: " + hardcodedEncryptionKey;
    }

    /**
     * 不安全示例：使用过短的加密密钥
     * 漏洞点：
     * 1. AES密钥长度仅64位，远低于安全标准
     * 2. 短密钥可被暴力破解（尝试所有可能的密钥组合）
     * 风险：加密数据可被暴力破解工具在短时间内解密
     * 修复方案：
     * 1. AES算法至少使用128位密钥
     * 2. 敏感场景推荐使用256位密钥
     * 3. 遵循NIST等权威机构的密钥长度推荐标准
     */
    @GetMapping("/unsafe/short-encryption-key")
    public String unsafeUseShortEncryptionKey() throws Exception {
        KeyGenerator keyGenerator = KeyGenerator.getInstance("AES");
        // 危险实践：生成64位AES密钥（安全标准要求至少128位）
        keyGenerator.init(64);
        return "已生成过短的64位AES加密密钥";
    }

    /**
     * 不安全示例：使用弱随机数生成器
     * 漏洞点：
     * 1. 使用java.util.Random，其生成的是伪随机数，可预测
     * 2. 随机数种子可被预测，导致生成的密钥或IV不安全
     * 风险：攻击者可预测随机数序列，进而破解加密或伪造签名
     * 修复方案：
     * 1. 使用java.security.SecureRandom生成加密级随机数
     * 2. 避免手动设置种子，使用系统默认的熵源
     */
    @GetMapping("/unsafe/weak-random-generator")
    public String unsafeUseWeakRandomGenerator() {
        // 危险实践：使用非加密安全的随机数生成器
        java.util.Random insecureRandom = new java.util.Random(); 
        int randomValue = insecureRandom.nextInt();
        return "已使用不安全的随机数生成器，生成值: " + randomValue;
    }

    /**
     * 不安全示例：使用ECB加密模式
     * 漏洞点：
     * 1. ECB模式对相同明文块生成相同密文块，暴露数据模式
     * 2. 不使用IV，加密安全性完全依赖密钥
     * 风险：攻击者可通过密文模式推断明文结构，甚至篡改数据
     * 修复方案：
     * 1. 使用CBC、GCM等分组加密模式
     * 2. GCM模式同时提供加密和完整性校验，推荐优先使用
     * 3. 确保每个加密操作使用随机生成的IV
     */
    @GetMapping("/unsafe/ecb-mode")
    public String unsafeUseEcbMode() throws Exception {
        // 危险实践：使用ECB模式（电子密码本模式）
        Cipher ecbCipher = Cipher.getInstance("AES/ECB/PKCS5Padding"); 
        return "已使用不安全的ECB加密模式";
    }

    /**
     * 不安全示例：密钥派生方法薄弱
     * 漏洞点：
     * 1. 直接将密码字符串转换为密钥，未使用密钥派生函数
     * 2. 密钥强度完全依赖原始密码强度，易被暴力破解
     * 风险：弱密码可被快速破解，导致加密失效
     * 修复方案：
     * 1. 使用PBKDF2、Bcrypt等密钥派生函数
     * 2. 设置足够的迭代次数和盐值（salt）
     * 3. 盐值应随机生成且与派生结果一同存储
     */
    @GetMapping("/unsafe/weak-key-derivation")
    public String unsafeUseWeakKeyDerivation() throws Exception {
        String userPassword = "password123";
        // 危险实践：直接将密码字节作为密钥（未使用密钥派生）
        byte[] insecureKey = userPassword.getBytes(); 
        SecretKeySpec key = new SecretKeySpec(insecureKey, "AES");
        return "已使用不安全的方式从密码派生密钥";
    }

    /**
     * 不安全示例：重用密钥用于多种用途
     * 漏洞点：
     * 1. 同一密钥同时用于加密和消息认证码(MAC)
     * 2. 密钥复用违反密钥使用的最小权限原则
     * 风险：一种用途的漏洞可能影响其他用途的安全性，扩大攻击面
     * 修复方案：
     * 1. 为不同加密目的使用独立密钥
     * 2. 使用密钥派生函数从主密钥生成多个子密钥
     * 3. 明确划分密钥的使用范围和生命周期
     */
    @GetMapping("/unsafe/key-reuse")
    public String unsafeReuseEncryptionKey() throws Exception {
        // 危险实践：同一密钥用于多种加密场景
        byte[] keyBytes = "1234567890abcdef".getBytes();
        SecretKeySpec reusedKey = new SecretKeySpec(keyBytes, "AES");
        
        // 场景1：用于数据加密
        Cipher encryptionCipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
        
        // 场景2：潜在用于消息认证（同一密钥）
        return "已将同一密钥用于多种加密用途";
    }

    /**
     * 不安全示例：密码存储方式薄弱
     * 漏洞点：
     * 1. 使用Base64编码存储密码（并非加密或哈希）
     * 2. Base64是可逆编码，等同于明文存储密码
     * 风险：数据库泄露即导致所有用户密码直接暴露
     * 修复方案：
     * 1. 使用专门的密码哈希算法（BCrypt、Argon2、PBKDF2）
     * 2. 每个密码使用唯一盐值（salt）
     * 3. 设置适当的工作因子（如迭代次数）抵御暴力破解
     */
    @GetMapping("/unsafe/weak-password-storage")
    public String unsafePasswordStorage() throws Exception {
        String userPassword = "userPassword123";
        // 危险实践：使用Base64编码存储密码（等同于明文）
        String encodedPassword = Base64.getEncoder().encodeToString(userPassword.getBytes());
        return "已使用不安全的方式存储密码: " + encodedPassword;
    }

    /**
     * 不安全示例：缺少数据完整性校验
     * 漏洞点：
     * 1. 仅使用加密而未验证数据完整性和真实性
     * 2. 无法检测密文是否被篡改
     * 风险：攻击者可篡改加密数据，导致系统使用错误数据
     * 修复方案：
     * 1. 使用带认证的加密模式（如AES-GCM）
     * 2. 对加密数据添加消息认证码(MAC)
     * 3. 确保校验过程在解密前进行，且失败时拒绝处理
     */
    @GetMapping("/unsafe/missing-integrity-check")
    public String unsafeMissingIntegrityCheck() throws Exception {
        // 危险实践：仅加密数据但不验证完整性
        Cipher encryptionOnlyCipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
        return "已加密数据但未添加完整性校验机制";
    }

    /**
     * 不安全示例：密钥交换方式不安全
     * 漏洞点：
     * 1. 明文传输密钥，未使用安全的密钥交换协议
     * 2. 密钥在传输过程中可被窃听获取
     * 风险：攻击者可拦截密钥，进而解密所有后续通信
     * 修复方案：
     * 1. 使用Diffie-Hellman等密钥交换算法
     * 2. 通过TLS协议进行密钥协商和传输
     * 3. 确保密钥交换过程具备前向安全性
     */
    @GetMapping("/unsafe/weak-key-exchange")
    public String unsafeKeyExchangeMethod() {
        // 危险实践：明文传输密钥（实际系统中可能通过未加密通道发送）
        String secretEncryptionKey = "secretKey123456";
        return "已使用不安全的方式交换密钥: " + secretEncryptionKey;
    }

    /**
     * 不安全示例：使用过时的SSL/TLS版本
     * 漏洞点：
     * 1. 使用SSLv3、TLS 1.0等已被破解的协议版本
     * 2. 这些版本存在POODLE、BEAST等已知漏洞
     * 风险：攻击者可利用协议漏洞窃取加密通信内容
     * 修复方案：
     * 1. 至少使用TLS 1.2，推荐TLS 1.3
     * 2. 禁用所有不安全的协议版本和加密套件
     * 3. 定期更新SSL/TLS配置以应对新漏洞
     */
    @GetMapping("/unsafe/obsolete-tls-version")
    public String unsafeUseObsoleteTlsVersion() {
        // 危险实践：配置使用已过时的TLS版本
        String tlsVersion = "TLSv1.0"; // 存在多个已知安全漏洞
        return "已使用不安全的过时TLS版本: " + tlsVersion;
    }

    /**
     * 不安全示例：随机数生成器种子不安全
     * 漏洞点：
     * 1. 使用可预测的时间戳作为SecureRandom的种子
     * 2. 种子熵值低，导致生成的随机数可预测
     * 风险：基于这些随机数的密钥或IV可被预测，加密失效
     * 修复方案：
     * 1. 不手动设置种子，依赖系统默认熵源
     * 2. 确保系统有足够的熵源（如使用硬件随机数生成器）
     * 3. 仅在必要时初始化，避免频繁重置种子
     */
    @GetMapping("/unsafe/weak-prng-seed")
    public String unsafePrngSeeding() {
        SecureRandom random = new SecureRandom();
        // 危险实践：使用可预测的时间戳作为种子
        random.setSeed(System.currentTimeMillis()); 
        return "已使用不安全的方式为随机数生成器播种";
    }

    /**
     * 不安全示例：密码学操作异常处理不当
     * 漏洞点：
     * 1. 直接向客户端返回加密操作的详细异常信息
     * 2. 错误信息可能泄露系统实现细节
     * 风险：攻击者可通过错误信息推断加密机制，实施针对性攻击
     * 修复方案：
     * 1. 捕获异常后返回通用错误信息
     * 2. 详细错误信息仅记录在服务器日志
     * 3. 避免泄露算法类型、密钥长度等敏感信息
     */
    @GetMapping("/unsafe/crypto-error-handling")
    public String unsafeCryptoErrorHandling() {
        try {
            // 模拟加密操作失败
            throw new Exception("AES加密失败: 密钥长度不符合要求 (实际错误信息不应暴露)");
        } catch (Exception e) {
            // 危险实践：直接返回详细异常信息给客户端
            return "加密操作失败: " + e.getMessage();
        }
    }
}
