package com.freedom.securitysamples.api.scriptEngineInjection;

import org.openjdk.nashorn.api.scripting.NashornScriptEngine;
import org.openjdk.nashorn.api.scripting.NashornScriptEngineFactory;
import org.springframework.web.bind.annotation.*;
import javax.script.*;
import java.io.FileReader;
import java.io.StringReader;

/**
 * 脚本引擎注入漏洞示例控制器
 * 说明：Java Script Engine允许执行多种脚本语言（如JavaScript、Python等），
 * 若直接执行用户可控的脚本内容，会导致远程代码执行（RCE）漏洞
 * 安全风险：攻击者可注入恶意脚本，执行系统命令、访问敏感资源、破坏系统完整性
 * 修复建议：1. 避免执行用户提供的任何脚本内容 2. 若必须使用，采用严格的沙箱机制 3. 禁用危险类和方法的访问
 */
@RestController
@RequestMapping("/security-example/script-engine")
public class ScriptEngineInjectionVulnerabilityController {

    /**
     * 不安全示例1：通过ScriptEngineManager执行用户提供的脚本
     * 漏洞点：直接将用户输入作为脚本内容执行，无任何过滤
     * 攻击示例：传入 "java.lang.Runtime.getRuntime().exec('calc.exe')" 可执行计算器
     */
    @GetMapping("/unsafe/engine-manager-exec")
    public String unsafeScriptExecutionByManager(@RequestParam String userControlledScript) throws ScriptException {
        // 创建脚本引擎管理器
        ScriptEngineManager engineManager = new ScriptEngineManager();
        // 获取Nashorn JavaScript引擎
        ScriptEngine nashornEngine = engineManager.getEngineByName("nashorn");
        
        // 危险操作：直接执行用户提供的脚本
        nashornEngine.eval(userControlledScript);
        return "{\"status\":\"脚本执行完成（不安全）\"}";
    }

    /**
     * 不安全示例2：通过ScriptEngineFactory执行用户提供的脚本
     * 漏洞点：使用工厂模式创建引擎并执行用户脚本，同样存在注入风险
     * 风险场景：启用-scripting参数可能增加更多攻击面
     */
    @GetMapping("/unsafe/engine-factory-exec")
    public String unsafeScriptExecutionByFactory(@RequestParam String userControlledScript) throws ScriptException {
        // 创建Nashorn脚本引擎工厂
        NashornScriptEngineFactory engineFactory = new NashornScriptEngineFactory();
        // 创建带有脚本模式的引擎（可能增加风险）
        NashornScriptEngine nashornEngine = (NashornScriptEngine) engineFactory.getScriptEngine(new String[]{"-scripting"});
        
        // 危险操作：执行用户提供的脚本并返回结果
        Object scriptResult = nashornEngine.eval(userControlledScript);
        return "{\"status\":\"脚本执行完成（不安全）\", \"result\":\"" + scriptResult + "\"}";
    }

    /**
     * 不安全示例3：从用户指定的文件读取并执行脚本
     * 漏洞点：允许用户控制脚本文件路径，可导致任意文件读取和脚本执行
     * 攻击示例：传入敏感系统文件路径或恶意脚本文件路径
     */
    @GetMapping("/unsafe/file-based-exec")
    public String unsafeScriptExecutionFromFile(@RequestParam String userProvidedFilePath) throws Exception {
        ScriptEngine engine = new ScriptEngineManager().getEngineByName("nashorn");
        
        // 危险操作：直接读取并执行用户指定路径的文件内容
        engine.eval(new FileReader(userProvidedFilePath));
        return "{\"status\":\"文件脚本执行完成（不安全）\"}";
    }

    /**
     * 不安全示例4：绑定危险变量后执行脚本
     * 漏洞点：将系统敏感类绑定到脚本环境中，扩大攻击面
     * 风险放大：暴露System类会让攻击者更容易执行系统命令
     */
    @GetMapping("/unsafe/binding-exec")
    public String unsafeScriptExecutionWithBinding(@RequestParam String userControlledScript) throws ScriptException {
        ScriptEngine engine = new ScriptEngineManager().getEngineByName("nashorn");
        Bindings bindings = engine.createBindings();
        
        // 危险操作：将System类暴露给脚本环境
        bindings.put("system", System.class);
        // 执行用户脚本，此时脚本可通过system变量访问系统资源
        engine.eval(userControlledScript, bindings);
        return "{\"status\":\"带绑定变量的脚本执行完成（不安全）\"}";
    }

    /**
     * 不安全示例5：编译并执行用户提供的脚本
     * 漏洞点：编译过程无法过滤恶意代码，只是提高执行效率
     * 风险说明：编译后的脚本依然会执行所有恶意代码
     */
    @GetMapping("/unsafe/compiled-exec")
    public String unsafeCompiledScriptExecution(@RequestParam String userControlledScript) throws Exception {
        ScriptEngine engine = new ScriptEngineManager().getEngineByName("nashorn");
        Compilable compilableEngine = (Compilable) engine;
        
        // 危险操作：编译用户提供的脚本（无法解决安全问题）
        CompiledScript compiledScript = compilableEngine.compile(userControlledScript);
        // 执行编译后的恶意脚本
        compiledScript.eval();
        return "{\"status\":\"编译后的脚本执行完成（不安全）\"}";
    }

    /**
     * 不安全示例6：调用脚本中的函数
     * 漏洞点：允许用户控制脚本内容和函数名，可执行任意函数
     * 攻击场景：攻击者可定义恶意函数并诱导系统调用
     */
    @GetMapping("/unsafe/function-invocation")
    public String unsafeScriptFunctionInvocation(
            @RequestParam String userControlledScript, 
            @RequestParam String functionName) throws Exception {
        ScriptEngine engine = new ScriptEngineManager().getEngineByName("nashorn");
        // 执行包含函数定义的用户脚本
        engine.eval(userControlledScript);
        
        Invocable invocableEngine = (Invocable) engine;
        // 危险操作：调用用户指定的函数
        invocableEngine.invokeFunction(functionName);
        return "{\"status\":\"脚本函数调用完成（不安全）\"}";
    }

    /**
     * 不安全示例7：多脚本引擎组合使用
     * 漏洞点：不同引擎可能有不同的安全特性，组合使用可能产生复杂攻击面
     * 风险说明：攻击者可利用不同引擎的特性构造更复杂的攻击链
     */
    @GetMapping("/unsafe/multi-engine-exec")
    public String unsafeMultipleEnginesExecution(@RequestParam String userControlledScript) throws Exception {
        ScriptEngineManager engineManager = new ScriptEngineManager();
        // 获取JavaScript引擎
        ScriptEngine jsEngine = engineManager.getEngineByName("nashorn");
        // 尝试获取Python引擎
        ScriptEngine pythonEngine = engineManager.getEngineByName("python");
        
        // 危险操作：在多个引擎中执行相同的用户脚本
        jsEngine.eval(userControlledScript);
        if (pythonEngine != null) {
            pythonEngine.eval(userControlledScript);
        }
        return "{\"status\":\"多引擎脚本执行完成（不安全）\"}";
    }

    /**
     * 不安全示例8：通过StringReader执行脚本
     * 漏洞点：无论通过何种输入方式（直接字符串或Reader），执行用户脚本都存在风险
     * 风险说明：输入方式不影响安全性，核心问题是执行不可信的脚本内容
     */
    @GetMapping("/unsafe/reader-based-exec")
    public String unsafeScriptExecutionFromReader(@RequestParam String userControlledScript) throws Exception {
        ScriptEngine engine = new ScriptEngineManager().getEngineByName("nashorn");
        // 将用户脚本包装为StringReader
        StringReader scriptReader = new StringReader(userControlledScript);
        
        // 危险操作：通过Reader执行用户脚本（与直接执行字符串同样危险）
        engine.eval(scriptReader);
        return "{\"status\":\"通过Reader执行脚本完成（不安全）\"}";
    }
}
    