package com.freedom.securitysamples.api.hardcodedCredentials;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import java.sql.Connection;
import java.sql.DriverManager;

/**
 * 硬编码凭证安全漏洞示例控制器
 * 说明：硬编码凭证是指在代码中直接嵌入密码、密钥、令牌等敏感信息，
 *       这些信息会随代码一起存储在版本控制系统中，可能被未授权人员获取，
 *       导致严重的安全风险。
 * 常见风险：
 * 1. 代码泄露导致敏感凭证直接暴露
 * 2. 凭证难以更新（需修改代码并重新部署）
 * 3. 所有环境（开发、测试、生产）共享同一凭证
 * 4. 权限过度分配（代码中使用高权限账号）
 * 修复原则：
 * 1. 使用环境变量存储敏感信息
 * 2. 采用配置文件（如application.properties）分离配置与代码
 * 3. 使用密钥管理服务（如AWS KMS、HashiCorp Vault）
 * 4. 不同环境使用不同凭证，并遵循最小权限原则
 * 5. 定期轮换凭证，且无需修改代码
 */
@RestController
@RequestMapping("/security-example/hardcoded-credentials")
public class HardcodedCredentialsVulnerabilityController {

    /**
     * 不安全示例：硬编码的敏感密码与密钥
     * 漏洞点：
     * 1. 密码和访问密钥直接写入代码中
     * 2. 所有环境使用相同的凭证
     * 风险：
     * 1. 代码提交到版本库后，凭证永久存储在代码历史中
     * 2. 任何能访问代码的人都能获取这些敏感信息
     * 3. 凭证更新需修改代码，成本高且易被遗漏
     */
    @GetMapping("/unsafe/hardcoded-secrets")
    public String unsafeHardcodedSecrets() {
        // 危险实践：敏感信息直接硬编码在代码中
        String hardcodedPassword = "letMeIn!";          // 硬编码密码
        String hardcodedApiAccessKeyId = "letMeIn!";     // 硬编码API访问ID
        String hardcodedApiSecretKey = "letMeIn!";       // 硬编码API密钥
        
        return "{\"msg\":\"敏感信息已硬编码（风险）\"}";
    }

    /**
     * 不安全示例：数据库连接中的硬编码凭证
     * 漏洞点：
     * 1. 数据库URL、用户名、密码直接嵌入代码
     * 2. 可能使用高权限数据库账号（如root）
     * 风险：
     * 1. 攻击者获取代码后可直接连接数据库，窃取或篡改数据
     * 2. 不同环境（开发/生产）可能共用同一账号，扩大风险范围
     * 3. 凭证泄露后需修改代码才能更换，响应迟缓
     */
    @GetMapping("/unsafe/db-connection")
    public String unsafeDbConnection() {
        try {
            // 危险实践：数据库凭证硬编码
            String dbUrl = "jdbc:mysql://localhost:3306/test";
            String dbUsername = "root";          // 硬编码数据库用户名（高权限风险）
            String dbPassword = "123456";        // 硬编码数据库密码（弱密码加剧风险）
            
            Connection conn = DriverManager.getConnection(dbUrl, dbUsername, dbPassword);
            return "{\"msg\":\"数据库已连接（使用硬编码凭证）\"}";
        } catch(Exception e) {
            return "{\"msg\":\"数据库连接失败\"}";
        }
    }

    /**
     * 不安全示例：硬编码的云服务API密钥
     * 漏洞点：
     * 1. 云服务访问密钥直接写入代码
     * 2. 使用final修饰符固定密钥，无法动态更新
     * 风险：
     * 1. 密钥泄露可能导致云服务资源被滥用，产生巨额费用
     * 2. 密钥轮换需修改代码并重新部署，操作复杂
     * 3. 所有实例共享同一密钥，无法精准控制权限和审计
     */
    @GetMapping("/unsafe/cloud-api-keys")
    public String unsafeCloudApiKeys() {
        // 危险实践：云服务密钥硬编码
        final String AWS_ACCESS_KEY = "AKIAIOSFODNN7EXAMPLE";      // 硬编码AWS访问密钥
        final String AWS_SECRET_KEY = "wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY";  // 硬编码AWS密钥
        
        return "{\"msg\":\"云服务API密钥已硬编码（风险）\"}";
    }

    /**
     * 不安全示例：硬编码的加密密钥
     * 漏洞点：
     * 1. 加密密钥和初始化向量直接嵌入代码
     * 2. 密钥强度不足（简单字符串易被猜测）
     * 风险：
     * 1. 攻击者获取密钥后可解密所有加密数据
     * 2. 无法灵活更换密钥，一旦泄露需重新加密所有数据
     * 3. 所有环境使用相同密钥，增加整体泄露风险
     */
    @GetMapping("/unsafe/encryption-keys")
    public String unsafeEncryptionKeys() {
        // 危险实践：加密密钥硬编码
        String hardcodedEncryptionKey = "MySecretEncryptionKey123!";  // 硬编码加密密钥（强度不足）
        String hardcodedInitVector = "RandomInitVector";              // 硬编码初始化向量
        
        return "{\"msg\":\"加密密钥已硬编码（风险）\"}";
    }

    /**
     * 不安全示例：硬编码的认证令牌
     * 漏洞点：
     * 1. Bearer令牌和刷新令牌直接写入代码
     * 2. 令牌长期有效且无法动态更新
     * 风险：
     * 1. 攻击者获取令牌后可冒充合法用户访问系统
     * 2. 令牌过期或泄露后需修改代码更新，响应滞后
     * 3. 所有用户/实例共享同一令牌，无法精准吊销
     */
    @GetMapping("/unsafe/auth-tokens")
    public String unsafeAuthTokens() {
        // 危险实践：认证令牌硬编码
        String hardcodedBearerToken = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...";  // 硬编码访问令牌
        String hardcodedRefreshToken = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."; // 硬编码刷新令牌
        
        return "{\"msg\":\"认证令牌已硬编码（风险）\"}";
    }

    /**
     * 不安全示例：硬编码的第三方服务凭证
     * 漏洞点：
     * 1. 第三方支付服务（PayPal、Stripe）的凭证直接嵌入代码
     * 2. 不同服务的凭证混在一起，缺乏隔离
     * 风险：
     * 1. 凭证泄露可能导致第三方服务被滥用，产生财务损失
     * 2. 第三方服务权限无法精细化控制，过度授权
     * 3. 凭证更新需修改代码，与第三方服务的密钥轮换机制冲突
     */
    @GetMapping("/unsafe/third-party-credentials")
    public String unsafeThirdPartyCredentials() {
        // 危险实践：第三方服务凭证硬编码
        String paypalClientId = "client_id_12345";         // 硬编码PayPal客户端ID
        String paypalSecret = "client_secret_67890";       // 硬编码PayPal密钥
        String stripeApiKey = "sk_test_4eC39HqLyjWDarjtT1zdp7dc";  // 硬编码Stripe密钥
        
        return "{\"msg\":\"第三方服务凭证已硬编码（风险）\"}";
    }

    /**
     * 不安全示例：硬编码的管理员凭证
     * 漏洞点：
     * 1. 管理员账号和密码直接写入代码
     * 2. 使用弱密码（admin123）且长期不变
     * 风险：
     * 1. 攻击者可直接获取最高权限，完全控制系统
     * 2. 所有部署实例共享同一管理员账号，无法区分操作来源
     * 3. 弱密码易被暴力破解，结合硬编码导致双重风险
     */
    @GetMapping("/unsafe/admin-credentials")
    public String unsafeAdminCredentials() {
        // 危险实践：管理员凭证硬编码（结合弱密码）
        String adminUsername = "admin";         // 硬编码管理员用户名（默认值风险）
        String adminPassword = "admin123";      // 硬编码管理员密码（弱密码风险）
        
        return "{\"msg\":\"管理员凭证已硬编码（高风险）\"}";
    }

    /**
     * 不安全示例：硬编码的SSH密钥
     * 漏洞点：
     * 1. SSH私钥和公钥直接嵌入代码
     * 2. 私钥未加密存储，完全暴露
     * 风险：
     * 1. 攻击者获取私钥后可远程登录服务器，完全控制系统
     * 2. 私钥无法安全轮换，泄露后需重新部署所有实例
     * 3. 同一密钥用于多台服务器，泄露后导致大规模安全事件
     */
    @GetMapping("/unsafe/ssh-keys")
    public String unsafeSshKeys() {
        // 危险实践：SSH密钥硬编码
        String privateKey = "-----BEGIN RSA PRIVATE KEY-----\nMIIEpQIBAAKCAQEA...";  // 硬编码SSH私钥
        String publicKey = "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQ...";            // 硬编码SSH公钥
        
        return "{\"msg\":\"SSH密钥已硬编码（极高风险）\"}";
    }
}
