package com.freedom.securitysamples.api.regularExpressionDOS;

import org.springframework.web.bind.annotation.*;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;

/**
 * 正则表达式DOS(ReDoS)漏洞示例控制器
 * 说明：ReDoS（Regular Expression Denial of Service）是因正则表达式设计不当，
 * 在处理特定恶意输入时产生大量回溯计算，导致服务响应缓慢甚至崩溃的攻击方式。
 * 漏洞根源：包含"贪婪匹配"、"嵌套重复"、"可选分组"等特性的正则表达式，面对精心构造的输入时，
 * 会产生指数级时间复杂度的计算（如(a+)+b匹配大量'a'结尾无'b'的字符串）。
 * 防护原则：1. 避免使用复杂/嵌套重复的正则表达式 2. 严格限制输入字符串长度 3. 设置正则匹配超时 4. 优先使用简单验证逻辑
 */
@RestController
@RequestMapping("/security-example/regex-dos")
public class RegexDosVulnerabilityController {

    /**
     * 不安全示例1：直接使用用户输入作为正则表达式
     * 漏洞点：允许用户提供任意正则表达式，攻击者可构造本身就存在ReDoS风险的恶意表达式
     * 攻击场景：用户传入"(a+)+b"作为正则，再传入超长的"aaaaa..."字符串，导致服务卡慢
     */
    @GetMapping("/unsafe/user-provided-pattern")
    public boolean unsafeRegexWithUserPattern(
            @RequestParam String userProvidedRegex,  // 用户可控的正则表达式，风险源
            @RequestParam String inputString) {      // 待匹配的输入字符串
        // 危险操作：直接使用未验证的用户输入作为正则表达式进行匹配
        return inputString.matches(userProvidedRegex);
    }

    /**
     * 不安全示例2：使用易引发回溯的正则表达式模式
     * 漏洞点：正则表达式包含"(a+)+b"这种嵌套重复结构，存在"灾难性回溯"风险
     * 原理：当输入为大量'a'（如1000个'a'）且结尾无'b'时，引擎会尝试所有可能的分组组合，导致计算量爆炸
     */
    @GetMapping("/unsafe/nested-repetition")
    public boolean unsafeRegexWithNestedRepetition(@RequestParam String inputString) {
        // 危险正则：(a+)+ 是嵌套的贪婪匹配，b是终止条件
        String vulnerableRegex = "(a+)+b";
        // 当inputString为"aaaaa..."（大量a且无b）时，会触发ReDoS
        return Pattern.matches(vulnerableRegex, inputString);
    }

    /**
     * 不安全示例3：未限制长度的复杂邮箱验证正则
     * 漏洞点：过于复杂的正则表达式+无输入长度限制，即使逻辑合理也可能被针对性攻击
     * 风险：超长邮箱字符串会放大正则匹配的计算量，导致响应延迟
     */
    @GetMapping("/unsafe/complex-email-validation")
    public boolean unsafeEmailValidationWithoutLengthLimit(@RequestParam String email) {
        // 问题：正则过于复杂（包含多个嵌套分组和范围匹配），且未限制email长度
        String overComplexEmailRegex = "^([a-zA-Z0-9_\\-\\.]+)@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.)|(([a-zA-Z0-9\\-]+\\.)+))([a-zA-Z]{2,4}|[0-9]{1,3})(\\]?)$";
        return email.matches(overComplexEmailRegex);
    }

    /**
     * 不安全示例4：包含多重重复的正则表达式
     * 漏洞点：正则包含"([a-z]+)*"和"([a-z]+)+"多重重复结构，放大回溯可能性
     * 攻击输入：超长小写字母字符串（如2000个'a'）且结尾无'b'，会触发大量回溯
     */
    @PostMapping("/unsafe/multiple-repetition")
    public boolean unsafeRegexWithMultipleRepetition(@RequestBody String inputText) {
        // 危险结构：多重重复嵌套，容易产生指数级回溯路径
        String riskyRegex = "([a-z]+)*([a-z]+)+b";
        return Pattern.matches(riskyRegex, inputText);
    }

    /**
     * 不安全示例5：带有大量可选分组的正则表达式
     * 漏洞点："(a|b|c|d|e|f|g)+"包含多个可选分支，匹配时会尝试多种组合导致效率低下
     * 风险：输入越长，可选分支的组合可能性越多，计算耗时呈几何增长
     */
    @GetMapping("/unsafe/many-alternatives")
    public boolean unsafeRegexWithManyAlternatives(@RequestParam String inputString) {
        // 危险点：多个可选分支+贪婪匹配，容易产生冗余计算
        String complexRegexWithAlternatives = "(a|b|c|d|e|f|g)+\\w*";
        return Pattern.compile(complexRegexWithAlternatives).matcher(inputString).matches();
    }

    /**
     * 安全示例1：基础防护措施实现
     * 安全措施：1. 限制输入长度 2. 使用简单正则表达式 3. 设置匹配超时 4. 捕获异常
     * 原理：通过多重限制降低ReDoS风险，即使正则有轻微问题也不会导致严重后果
     */
    @GetMapping("/safe/basic-protection")
    public boolean safeRegexWithProtection(@RequestParam String inputString) {
        // 防护1：限制输入长度（根据业务场景设定合理上限）
        if (inputString.length() > 100) {
            return false;  // 超长输入直接拒绝
        }

        try {
            // 防护2：使用简单正则（避免嵌套重复、复杂分支）
            // 防护3：设置匹配超时（Java 8+支持，单位：毫秒）
            Pattern pattern = Pattern.compile("[a-zA-Z0-9]+", Pattern.CASE_INSENSITIVE);
            return pattern.matcher(inputString)
                    .matches();
        } catch (PatternSyntaxException e) {
            // 正则语法错误处理
            return false;
        } catch (Exception e) {
            // 匹配超时（可能是攻击），记录日志并拒绝
            return false;
        }
    }

    /**
     * 安全示例2：安全的邮箱验证实现
     * 安全措施：1. 严格限制输入长度（邮箱最长254字符是行业共识）
     *          2. 使用简化的正则表达式（放弃过度精确，优先保障安全）
     *          3. 避免复杂嵌套结构
     */
    @GetMapping("/safe/email-validation")
    public boolean safeEmailValidation(@RequestParam(required = false) String email) {
        // 防护1：校验非空和长度（254是邮箱最大长度标准）
        if (email == null || email.length() > 254) {
            return false;
        }

        // 防护2：使用简化正则（够用即可，减少计算复杂度）
        // 匹配规则：本地部分允许字母、数字、常见符号，@后允许任意合法域名
        String simpleEmailRegex = "^[A-Za-z0-9+_.-]+@(.+)$";
        return Pattern.compile(simpleEmailRegex)
                .matcher(email)
                .matches();
    }
}
    