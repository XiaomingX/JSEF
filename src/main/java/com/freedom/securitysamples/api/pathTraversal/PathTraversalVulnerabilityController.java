package com.freedom.securitysamples.api.pathTraversal;

import org.springframework.core.io.Resource;
import org.springframework.core.io.UrlResource;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

/**
 * 路径遍历漏洞示例控制器
 * 说明：路径遍历（Path Traversal）漏洞是指攻击者通过构造特殊路径字符串（如包含../、..\等），
 * 绕过系统对文件操作的路径限制，访问或操作未授权的文件/目录（如/etc/passwd、系统配置文件等）。
 * 安全风险：可能导致敏感信息泄露、文件篡改、系统命令执行（结合其他漏洞）等严重后果。
 * 修复建议：
 * 1. 对用户输入的路径进行严格验证，使用规范化处理（如Path.normalize()）
 * 2. 强制将文件操作限制在预设的基础目录内（通过startsWith()检查）
 * 3. 避免直接拼接用户输入作为文件路径，采用白名单允许的文件名/路径
 */
@RestController
@RequestMapping("/security-example/path-traversal")
public class PathTraversalVulnerabilityController {

    // 预设的基础目录（所有文件操作应限制在此目录内）
    private static final String UPLOAD_BASE_DIR = "/tmp/uploads/";

    /**
     * 不安全示例1：直接读取用户指定路径的文件内容
     * 漏洞点：未验证用户输入的文件路径，允许访问系统任意文件
     * 攻击示例：传入filePath=../../etc/passwd，可读取系统敏感文件
     */
    @GetMapping("/unsafe/read-content")
    public String unsafeFileContentReading(@RequestParam String userInputFilePath) throws IOException {
        // 危险操作：直接使用用户输入的路径创建文件对象
        File targetFile = new File(userInputFilePath);
        
        if (targetFile.exists()) {
            // 读取并返回文件内容（可能包含敏感信息）
            byte[] fileData = Files.readAllBytes(Paths.get(userInputFilePath));
            return new String(fileData);
        }
        return "文件路径：" + userInputFilePath;
    }

    /**
     * 不安全示例2：文件下载功能中的路径遍历
     * 漏洞点：用户输入的文件名直接拼接到基础路径，未过滤特殊字符
     * 攻击示例：传入fileName=../../../../var/log/syslog，可下载系统日志
     */
    @GetMapping("/unsafe/download")
    public ResponseEntity<Resource> unsafeFileDownload(@RequestParam String userInputFileName) throws IOException {
        // 危险拼接：用户输入直接拼接到基础路径，未做安全处理
        Path targetPath = Paths.get(UPLOAD_BASE_DIR + userInputFileName);
        Resource fileResource = new UrlResource(targetPath.toUri());
        
        // 直接返回文件资源（可能是未授权的敏感文件）
        return ResponseEntity.ok().body(fileResource);
    }

    /**
     * 不安全示例3：文件上传时的路径处理漏洞
     * 漏洞点：用户控制的目录名直接参与路径拼接，可跳转到任意目录
     * 攻击示例：传入directory=../../../../tmp，将文件上传到系统tmp目录
     */
    @PostMapping("/unsafe/upload")
    public String unsafeFileUpload(
            @RequestParam("file") MultipartFile uploadFile, 
            @RequestParam("directory") String userInputDir) throws IOException {
        // 危险拼接：用户输入的目录名直接拼接到基础路径
        String fullUploadPath = UPLOAD_BASE_DIR + userInputDir + "/" + uploadFile.getOriginalFilename();
        File destFile = new File(fullUploadPath);
        
        // 将文件保存到攻击者指定的路径（可能超出预期目录）
        uploadFile.transferTo(destFile);
        return "文件已上传至：" + fullUploadPath;
    }

    /**
     * 不安全示例4：ZIP文件解压时的路径遍历
     * 漏洞点：未检查ZIP包内文件的路径，可能包含../等特殊序列
     * 攻击示例：ZIP包内文件名为"../../etc/cron.d/malicious"，解压后会覆盖系统定时任务文件
     */
    @PostMapping("/unsafe/unzip")
    public String unsafeZipExtraction(
            @RequestParam("zipFile") MultipartFile zipFile, 
            @RequestParam("extractPath") String userInputExtractPath) throws IOException {
        File destDirectory = new File(userInputExtractPath);
        byte[] buffer = new byte[1024];
        ZipInputStream zipInputStream = new ZipInputStream(zipFile.getInputStream());
        ZipEntry zipEntry = zipInputStream.getNextEntry();
        
        while (zipEntry != null) {
            // 危险操作：直接使用ZIP内的文件名拼接解压路径
            File extractedFile = new File(destDirectory, zipEntry.getName());
            FileOutputStream fileOutputStream = new FileOutputStream(extractedFile);
            
            int bytesRead;
            while ((bytesRead = zipInputStream.read(buffer)) > 0) {
                fileOutputStream.write(buffer, 0, bytesRead);
            }
            fileOutputStream.close();
            zipEntry = zipInputStream.getNextEntry();
        }
        zipInputStream.closeEntry();
        zipInputStream.close();
        return "文件已解压至：" + userInputExtractPath;
    }

    /**
     * 不安全示例5：文件删除功能中的路径遍历
     * 漏洞点：用户输入的文件路径直接拼接基础目录，可删除任意文件
     * 攻击示例：传入filePath=../../../../var/lib/mysql/ibdata1，可能破坏数据库文件
     */
    @DeleteMapping("/unsafe/delete")
    public String unsafeFileDeletion(@RequestParam String userInputFilePath) {
        // 危险拼接：用户输入路径直接拼接到基础目录
        File targetFile = new File(UPLOAD_BASE_DIR + userInputFilePath);
        
        if (targetFile.delete()) {
            return "文件删除成功";
        }
        return "文件删除失败";
    }

    /**
     * 不安全示例6：文件流读取中的路径遍历
     * 漏洞点：通过输出流返回用户指定路径的文件内容，无路径限制
     * 攻击示例：传入filePath=../../../../root/.ssh/id_rsa，可窃取SSH私钥
     */
    @GetMapping("/unsafe/stream")
    public void unsafeFileStreaming(
            @RequestParam String userInputFilePath, 
            OutputStream responseOutputStream) throws IOException {
        // 危险操作：直接使用用户输入路径创建文件输入流
        FileInputStream fileInputStream = new FileInputStream(UPLOAD_BASE_DIR + userInputFilePath);
        byte[] buffer = new byte[1024];
        int bytesRead;
        
        // 将文件内容写入响应流（可能泄露敏感信息）
        while ((bytesRead = fileInputStream.read(buffer)) != -1) {
            responseOutputStream.write(buffer, 0, bytesRead);
        }
        fileInputStream.close();
    }

    /**
     * 不安全示例7：文件写入功能中的路径遍历
     * 漏洞点：用户输入的文件路径直接用于写入内容，可覆盖任意文件
     * 攻击示例：传入filePath=../../../../etc/hosts，可篡改系统hosts文件
     */
    @PostMapping("/unsafe/write")
    public String unsafeFileWriting(
            @RequestParam String content, 
            @RequestParam String userInputFilePath) throws IOException {
        // 危险操作：直接使用用户输入路径创建文件写入流
        FileWriter fileWriter = new FileWriter(UPLOAD_BASE_DIR + userInputFilePath);
        fileWriter.write(content);
        fileWriter.close();
        return "内容已写入文件";
    }

    /**
     * 不安全示例8：文件重命名功能中的路径遍历
     * 漏洞点：新旧路径均由用户控制，可移动文件到任意位置
     * 攻击示例：传入newPath=../../../../usr/bin/malicious，替换系统可执行文件
     */
    @PutMapping("/unsafe/rename")
    public String unsafeFileRename(
            @RequestParam String oldFilePath, 
            @RequestParam String newFilePath) {
        // 危险操作：直接使用用户输入的新旧路径
        File oldFile = new File(UPLOAD_BASE_DIR + oldFilePath);
        File newFile = new File(UPLOAD_BASE_DIR + newFilePath);
        
        if (oldFile.renameTo(newFile)) {
            return "文件重命名成功";
        }
        return "文件重命名失败";
    }
}
    