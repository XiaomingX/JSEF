package com.freedom.securitysamples.api.sqlInjection;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;

/**
 * SQL注入漏洞示例控制器
 * 说明：SQL注入是一种常见的Web安全漏洞，攻击者通过在输入参数中注入恶意SQL代码，
 *       从而操纵数据库执行非预期的操作，可能导致未授权的数据访问、数据篡改甚至服务器被控制。
 * 常见风险：
 * 1. 数据库信息泄露（用户数据、敏感配置等）
 * 2. 数据被非法篡改或删除
 * 3. 绕过身份验证机制
 * 4. 执行系统命令（在特定配置下）
 * 修复原则：
 * 1. 使用参数化查询（预编译语句）
 * 2. 避免直接拼接SQL语句
 * 3. 对用户输入进行严格验证和过滤
 * 4. 限制数据库用户权限
 * 5. 使用ORM框架（如MyBatis、Hibernate）的参数绑定功能
 */
@RestController
@RequestMapping("/security-example/sql-injection")
public class SqlInjectionVulnerabilityController {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    /**
     * 不安全示例：通过字符串拼接构建查询（单参数）
     * 漏洞点：直接将用户输入的用户名拼接到SQL语句中
     * 风险：攻击者可输入 ' OR '1'='1 等恶意字符串获取所有用户信息
     * 示例攻击输入：admin' OR '1'='1
     * 攻击后SQL：SELECT * FROM users WHERE username = 'admin' OR '1'='1'
     */
    @GetMapping("/unsafe/search-by-username")
    public List<Map<String, Object>> unsafeSearchByUsername(@RequestParam String username) {
        // 危险实践：直接拼接用户输入到SQL语句
        String sql = "SELECT * FROM users WHERE username = '" + username + "'";
        return jdbcTemplate.queryForList(sql);
    }

    /**
     * 不安全示例：动态拼接WHERE条件
     * 漏洞点：将用户输入直接作为WHERE子句的一部分
     * 风险：攻击者可构造任意条件，如 1=1; DROP TABLE users;--
     * 示例攻击输入：1=1; DROP TABLE users;--
     * 攻击后SQL：SELECT * FROM users WHERE 1=1; DROP TABLE users;--
     */
    @GetMapping("/unsafe/filter-by-condition")
    public List<Map<String, Object>> unsafeFilterByCondition(@RequestParam String condition) {
        // 极度危险：完全信任用户输入作为查询条件
        String sql = "SELECT * FROM users WHERE " + condition;
        return jdbcTemplate.queryForList(sql);
    }

    /**
     * 不安全示例：多参数拼接查询
     * 漏洞点：多个参数都通过字符串拼接方式加入SQL语句
     * 风险：任何一个参数被注入都可能导致整个查询被篡改
     * 示例攻击输入：email参数使用 ' OR 1=1--
     * 攻击后SQL：SELECT * FROM users WHERE username = 'user' AND email = '' OR 1=1--' AND role = 'role'
     */
    @GetMapping("/unsafe/advanced-search")
    public List<Map<String, Object>> unsafeAdvancedSearch(
            @RequestParam String username,
            @RequestParam String email,
            @RequestParam String role) {
        // 危险实践：多参数拼接，增加了注入风险点
        String sql = "SELECT * FROM users WHERE username = '" + username +
                "' AND email = '" + email +
                "' AND role = '" + role + "'";
        return jdbcTemplate.queryForList(sql);
    }

    /**
     * 不安全示例：ORDER BY子句注入
     * 漏洞点：将用户输入直接作为排序字段
     * 风险：攻击者可注入UNION查询或其他恶意代码
     * 示例攻击输入：username; DROP TABLE logs;--
     * 攻击后SQL：SELECT * FROM users ORDER BY username; DROP TABLE logs;--
     */
    @GetMapping("/unsafe/sort-by-column")
    public List<Map<String, Object>> unsafeSortByColumn(@RequestParam String sortColumn) {
        // 危险实践：直接使用用户输入作为排序字段
        String sql = "SELECT * FROM users ORDER BY " + sortColumn;
        return jdbcTemplate.queryForList(sql);
    }

    /**
     * 不安全示例：LIKE查询注入
     * 漏洞点：在模糊查询中直接拼接用户输入
     * 风险：攻击者可注入通配符或恶意SQL代码
     * 示例攻击输入：%' OR 1=1--
     * 攻击后SQL：SELECT * FROM users WHERE username LIKE '%'%' OR 1=1--%'
     */
    @GetMapping("/unsafe/search-like")
    public List<Map<String, Object>> unsafeSearchLike(@RequestParam String searchTerm) {
        // 危险实践：在LIKE查询中直接拼接用户输入
        String sql = "SELECT * FROM users WHERE username LIKE '%" + searchTerm + "%'";
        return jdbcTemplate.queryForList(sql);
    }

    /**
     * 不安全示例：IN子句注入
     * 漏洞点：将用户输入直接作为IN子句的参数列表
     * 风险：攻击者可注入额外的条件或恶意语句
     * 示例攻击输入：1) OR 1=1--
     * 攻击后SQL：SELECT * FROM users WHERE id IN (1) OR 1=1--)
     */
    @GetMapping("/unsafe/search-in-ids")
    public List<Map<String, Object>> unsafeSearchInIds(@RequestParam String userIds) {
        // 危险实践：直接拼接用户输入作为IN子句的参数
        String sql = "SELECT * FROM users WHERE id IN (" + userIds + ")";
        return jdbcTemplate.queryForList(sql);
    }

    /**
     * 不安全示例：UPDATE语句注入
     * 漏洞点：在更新语句中拼接用户输入
     * 风险：攻击者可修改任意记录的字段值
     * 示例攻击输入：userId=1' OR '1'='1，status='active'
     * 攻击后SQL：UPDATE users SET status = 'active' WHERE id = 1' OR '1'='1
     */
    @PostMapping("/unsafe/update-status")
    public int unsafeUpdateUserStatus(
            @RequestParam String userId,
            @RequestParam String status) {
        // 危险实践：在UPDATE语句中拼接用户输入
        String sql = "UPDATE users SET status = '" + status +
                "' WHERE id = " + userId;
        return jdbcTemplate.update(sql);
    }

    /**
     * 不安全示例：DELETE语句注入
     * 漏洞点：在删除语句中直接使用用户输入作为条件
     * 风险：攻击者可能删除表中所有数据甚至整个表
     * 示例攻击输入：1=1; DROP TABLE users;--
     * 攻击后SQL：DELETE FROM users WHERE 1=1; DROP TABLE users;--
     */
    @DeleteMapping("/unsafe/delete-by-condition")
    public int unsafeDeleteByCondition(@RequestParam String condition) {
        // 极度危险：允许用户输入直接决定删除条件
        String sql = "DELETE FROM users WHERE " + condition;
        return jdbcTemplate.update(sql);
    }

    /**
     * 不安全示例：JOIN查询注入
     * 漏洞点：在关联查询中拼接用户输入
     * 风险：攻击者可注入恶意条件获取其他表的敏感信息
     * 示例攻击输入：' OR 1=1 UNION SELECT * FROM passwords--
     * 攻击后SQL：SELECT u.* FROM users u JOIN departments d ON u.dept_id = d.id WHERE d.name = '' OR 1=1 UNION SELECT * FROM passwords--'
     */
    @GetMapping("/unsafe/join-search")
    public List<Map<String, Object>> unsafeJoinSearch(@RequestParam String deptName) {
        // 危险实践：在JOIN查询中拼接用户输入
        String sql = "SELECT u.* FROM users u " +
                "JOIN departments d ON u.dept_id = d.id " +
                "WHERE d.name = '" + deptName + "'";
        return jdbcTemplate.queryForList(sql);
    }

    /**
     * 不安全示例：GROUP BY查询注入
     * 漏洞点：将用户输入直接作为分组字段
     * 风险：攻击者可注入聚合函数或恶意语句
     * 示例攻击输入：1) UNION SELECT 1, version(), 3--
     * 攻击后SQL：SELECT 1) UNION SELECT 1, version(), 3--, COUNT(*) as count FROM users GROUP BY 1) UNION SELECT 1, version(), 3--
     */
    @GetMapping("/unsafe/group-stats")
    public List<Map<String, Object>> unsafeGroupStats(@RequestParam String groupField) {
        // 危险实践：直接使用用户输入作为分组字段
        String sql = "SELECT " + groupField + ", COUNT(*) as count " +
                "FROM users GROUP BY " + groupField;
        return jdbcTemplate.queryForList(sql);
    }

    /**
     * 安全示例：使用参数化查询（单参数）
     * 修复方式：使用?作为占位符，将参数作为查询参数传入
     * 原理：预编译SQL语句，用户输入仅作为参数值处理，不会被解析为SQL命令
     */
    @GetMapping("/safe/search-by-username")
    public List<Map<String, Object>> safeSearchByUsername(@RequestParam String username) {
        // 安全实践：使用参数化查询，防止SQL注入
        String sql = "SELECT * FROM users WHERE username = ?";
        return jdbcTemplate.queryForList(sql, username);
    }

    /**
     * 安全示例：多参数的参数化查询
     * 修复方式：为每个参数使用独立的占位符
     * 优势：即使有多个参数，每个参数都被安全处理，避免注入风险
     */
    @GetMapping("/safe/advanced-search")
    public List<Map<String, Object>> safeAdvancedSearch(
            @RequestParam String username,
            @RequestParam String email,
            @RequestParam String role) {
        // 安全实践：多参数均使用占位符
        String sql = "SELECT * FROM users WHERE username = ? AND email = ? AND role = ?";
        return jdbcTemplate.queryForList(sql, username, email, role);
    }
}