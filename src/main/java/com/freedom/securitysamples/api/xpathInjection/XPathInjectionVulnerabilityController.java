package com.freedom.securitysamples.api.xpathInjection;

import org.springframework.web.bind.annotation.*;
import javax.xml.xpath.*;
import org.xml.sax.InputSource;
import java.io.StringReader;
import org.jaxen.dom.DOMXPath;
import org.jaxen.JaxenException;
import org.w3c.dom.Document;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import java.util.List;
import java.net.URL;
import java.net.URLClassLoader;
import java.io.InputStream;
import java.io.ByteArrayInputStream;
import java.util.Base64;
import java.util.ServiceLoader;

/**
 * XPath注入漏洞示例控制器
 * 说明：XPath注入是攻击者通过在输入中注入恶意XPath表达式，操纵XML文档查询的安全漏洞。
 *       与SQL注入类似，但针对XML数据存储，可能导致未授权访问敏感XML数据、绕过权限验证等。
 * 常见风险：
 * 1. 敏感XML数据泄露（用户信息、配置数据等）
 * 2. 权限绕过（如认证场景中构造恶意表达式绕过验证）
 * 3. 信息枚举（通过布尔型注入猜测XML结构）
 * 修复原则：
 * 1. 避免直接使用用户输入构建XPath表达式
 * 2. 对用户输入进行严格验证（白名单机制）
 * 3. 使用参数化XPath查询（如支持的库）
 * 4. 限制XML文档访问权限，遵循最小权限原则
 * 5. 采用预定义的安全XPath模板，仅允许替换安全参数
 */
@RestController
@RequestMapping("/security-example/xpath-injection")
public class XPathInjectionVulnerabilityController {

    /**
     * 不安全示例：直接使用用户输入的XPath表达式和XML内容进行查询
     * 漏洞点：
     * 1. 完全信任用户提供的XPath表达式，未做任何过滤或验证
     * 2. 直接将用户输入作为查询逻辑执行，存在注入风险
     * 攻击示例：
     * 假设正常表达式为：//user[username='admin' and password='{input}']
     * 攻击者输入：' or '1'='1 ，构造出永真条件，绕过认证
     * 风险：攻击者可获取XML中所有数据，甚至推断XML结构进行进一步攻击
     */
    @GetMapping("/unsafe/evaluate-expression")
    public String unsafeEvaluateXPath(
            @RequestParam("expression") String userXpathExpression,
            @RequestParam("xml") String xmlContent) {
        try {
            // 危险实践：直接使用用户提供的XPath表达式
            XPathFactory xPathFactory = XPathFactory.newInstance();
            XPath xPath = xPathFactory.newXPath();

            // 编译并执行用户提供的表达式（注入风险点）
            XPathExpression xPathExpression = xPath.compile(userXpathExpression);
            InputSource inputSource = new InputSource(new StringReader(xmlContent));

            String result = xPathExpression.evaluate(inputSource);
            return "{\"result\":\"" + result + "\"}";
        } catch (XPathExpressionException e) {
            return "{\"error\":\"Invalid XPath expression or XML content\"}";
        }
    }

    /**
     * 不安全示例：使用Jaxen库处理用户提供的XPath表达式
     * 漏洞点：
     * 1. 接收用户输入的XPath表达式并直接执行
     * 2. 未对表达式进行安全校验，允许任意查询操作
     * 攻击示例：
     * 正常查询：//user[role='user']
     * 攻击者输入：//user[1] | //password ，同时获取用户和密码信息
     * 风险：攻击者可构造复杂表达式遍历整个XML文档，获取所有敏感信息
     */
    @GetMapping("/unsafe/evaluate-with-jaxen")
    public String unsafeEvaluateXPathWithJaxen(
            @RequestParam("expression") String userXpathExpression,
            @RequestParam("xml") String xmlContent) {
        try {
            // 解析XML内容
            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
            DocumentBuilder builder = factory.newDocumentBuilder();
            Document document = builder.parse(new InputSource(new StringReader(xmlContent)));

            // 危险实践：直接使用Jaxen执行用户提供的表达式
            DOMXPath domXPath = new DOMXPath(userXpathExpression);
            List<?> results = domXPath.selectNodes(document);

            // 拼接查询结果
            StringBuilder resultBuilder = new StringBuilder();
            resultBuilder.append("{\"results\": [");
            for (Object result : results) {
                resultBuilder.append("\"" + result.toString() + "\",");
            }
            if (!results.isEmpty()) {
                resultBuilder.setLength(resultBuilder.length() - 1); // 移除最后一个逗号
            }
            resultBuilder.append("]}");

            return resultBuilder.toString();
        } catch (JaxenException e) {
            return "{\"error\":\"Invalid XPath expression\"}";
        } catch (Exception e) {
            return "{\"error\":\"Invalid XML content or parsing error\"}";
        }
    }

    /**
     * 不安全示例：使用URLClassLoader加载不可信数据
     * 漏洞点：
     * 1. 加载用户提供的Base64编码数据，可能包含恶意字节码
     * 2. 使用URLClassLoader加载外部资源，存在代码执行风险
     * 风险：
     * 攻击者可构造恶意class文件，通过此接口加载并执行，获取服务器控制权
     * 属于远程代码执行(RCE)高风险漏洞
     */
    @GetMapping("/unsafe/load-with-url-classloader")
    public String unsafeLoadWithURLClassLoader(@RequestParam("data") String base64EncodedData) {
        try {
            // 危险实践：解码并加载用户提供的原始数据
            byte[] dataBytes = Base64.getDecoder().decode(base64EncodedData);
            InputStream inputStream = new ByteArrayInputStream(dataBytes);

            // 潜在风险点：URLClassLoader可加载外部资源执行
            URL[] urls = { new URL("file:") }; // 此处仅为示例，实际使用中风险更高
            URLClassLoader urlClassLoader = new URLClassLoader(urls);

            // 注意：实际场景中若将inputStream中的数据作为类加载，风险极大
            return "{\"result\":\"Data loaded (unsafe practice - potential RCE risk)\"}";
        } catch (Exception e) {
            return "{\"error\":\"Failed to process data (potential injection attempt)\"}";
        }
    }

    /**
     * 不安全示例：使用ServiceLoader加载用户指定的服务接口
     * 漏洞点：
     * 1. 允许用户指定任意服务接口进行加载
     * 2. 未限制可加载的类范围，存在类加载注入风险
     * 风险：
     * 攻击者可通过指定敏感系统接口，枚举或调用未授权服务，
     * 甚至结合其他漏洞实现权限提升或信息泄露
     */
    @GetMapping("/unsafe/load-with-service-loader")
    public String unsafeLoadWithServiceLoader(@RequestParam("serviceInterface") String serviceInterface) {
        try {
            // 危险实践：加载用户指定的任意类
            Class<?> serviceClass = Class.forName(serviceInterface);
            ServiceLoader<?> loader = ServiceLoader.load(serviceClass);

            // 枚举加载的服务（可能泄露系统信息）
            StringBuilder resultBuilder = new StringBuilder("{\"services\": [");
            for (Object service : loader) {
                resultBuilder.append("\"" + service.getClass().getName() + "\",");
            }
            if (resultBuilder.length() > 13) { // 检查是否有内容
                resultBuilder.setLength(resultBuilder.length() - 1); // 移除最后一个逗号
            }
            resultBuilder.append("]}");

            return resultBuilder.toString();
        } catch (Exception e) {
            return "{\"error\":\"Failed to load service (potential class injection attempt)\"}";
        }
    }
}
